"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/colorUtils.ts":
/*!*********************************!*\
  !*** ./src/utils/colorUtils.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   generateColorScale: () => (/* binding */ generateColorScale),\n/* harmony export */   generateNeutrals: () => (/* binding */ generateNeutrals),\n/* harmony export */   hexToRgb: () => (/* binding */ hexToRgb),\n/* harmony export */   hslToRgb: () => (/* binding */ hslToRgb),\n/* harmony export */   rgbToHex: () => (/* binding */ rgbToHex),\n/* harmony export */   rgbToHsl: () => (/* binding */ rgbToHsl)\n/* harmony export */ });\n/**\n * Converts a hex color to RGB components\n */ function hexToRgb(hex) {\n    // Remove the hash if present\n    hex = hex.replace(/^#/, '');\n    // Parse the hex value\n    let r, g, b;\n    if (hex.length === 3) {\n        r = parseInt(hex[0] + hex[0], 16);\n        g = parseInt(hex[1] + hex[1], 16);\n        b = parseInt(hex[2] + hex[2], 16);\n    } else {\n        r = parseInt(hex.substring(0, 2), 16);\n        g = parseInt(hex.substring(2, 4), 16);\n        b = parseInt(hex.substring(4, 6), 16);\n    }\n    return {\n        r,\n        g,\n        b\n    };\n}\n/**\n * Converts RGB components to a hex color\n */ function rgbToHex(r, g, b) {\n    return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);\n}\n/**\n * Converts RGB to HSL components\n */ function rgbToHsl(r, g, b) {\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    let h = 0;\n    let s = 0;\n    const l = (max + min) / 2;\n    if (max !== min) {\n        const d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        switch(max){\n            case r:\n                h = (g - b) / d + (g < b ? 6 : 0);\n                break;\n            case g:\n                h = (b - r) / d + 2;\n                break;\n            case b:\n                h = (r - g) / d + 4;\n                break;\n        }\n        h /= 6;\n    }\n    return {\n        h,\n        s,\n        l\n    };\n}\n/**\n * Converts HSL to RGB components\n */ function hslToRgb(h, s, l) {\n    let r, g, b;\n    if (s === 0) {\n        r = g = b = l; // achromatic\n    } else {\n        const hue2rgb = (p, q, t)=>{\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 1 / 2) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        };\n        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        const p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n    }\n    return {\n        r: Math.round(r * 255),\n        g: Math.round(g * 255),\n        b: Math.round(b * 255)\n    };\n}\n/**\n * Generates a color scale based on a base color\n * @param baseColor - The base color in hex format\n * @returns An object with color variants from 50 to 950\n */ function generateColorScale(baseColor) {\n    const rgb = hexToRgb(baseColor);\n    const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);\n    // Define lightness values for each step in the scale\n    const lightnessScale = {\n        '50': 0.97,\n        '100': 0.94,\n        '200': 0.86,\n        '300': 0.76,\n        '400': 0.66,\n        '500': 0.56,\n        '600': 0.46,\n        '700': 0.38,\n        '800': 0.3,\n        '900': 0.22,\n        '950': 0.14\n    };\n    // Adjust saturation based on base color's saturation\n    // For very low or very high saturation colors, we need to adjust to create a balanced scale\n    let saturationAdjust = 1;\n    if (hsl.s < 0.15) {\n        saturationAdjust = 3; // Boost saturation for gray-ish colors\n    } else if (hsl.s > 0.9) {\n        saturationAdjust = 0.85; // Reduce saturation for very saturated colors\n    }\n    const colorScale = {};\n    // Generate each step in the scale\n    Object.entries(lightnessScale).forEach((param)=>{\n        let [step, lightness] = param;\n        // Adjust saturation based on lightness\n        // Lighter colors should be less saturated, darker colors more saturated\n        let adjustedSaturation = hsl.s;\n        if (lightness > 0.7) {\n            adjustedSaturation = Math.min(1, hsl.s * 0.8 * saturationAdjust);\n        } else if (lightness < 0.3) {\n            adjustedSaturation = Math.min(1, hsl.s * 1.2 * saturationAdjust);\n        } else {\n            adjustedSaturation = Math.min(1, hsl.s * saturationAdjust);\n        }\n        const color = hslToRgb(hsl.h, adjustedSaturation, lightness);\n        colorScale[step] = rgbToHex(color.r, color.g, color.b);\n    });\n    return colorScale;\n}\n/**\n * Generates a set of neutral/grey colors that are derived from the primary color\n * @param primaryColor - The primary color in hex format\n * @returns An object with neutral color variants from 50 to 950\n */ function generateNeutrals(primaryColor) {\n    const rgb = hexToRgb(primaryColor);\n    const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);\n    // Derive a neutral palette by:\n    // 1. Taking the hue from the primary color\n    // 2. Significantly reducing the saturation\n    // 3. Using a similar lightness scale as the color scale\n    // Create a slight hue shift for more interesting neutrals\n    // Move the hue slightly toward blue for cool greys or toward orange for warm greys\n    // Based on where the original hue is located\n    let neutralHue = hsl.h;\n    // If the hue is in the blue/green range, shift toward warmer grey\n    if (neutralHue > 0.3 && neutralHue < 0.7) {\n        neutralHue = (neutralHue + 0.05) % 1; // Shift slightly warmer\n    } else {\n        // If the hue is in the red/orange/yellow range, shift toward cooler grey\n        neutralHue = (neutralHue + 0.95) % 1; // Shift slightly cooler\n    }\n    // Very low saturation for neutrals, but keep a hint of the color influence\n    const baseSaturation = Math.min(0.08, hsl.s * 0.12);\n    // Define lightness values for each step in the neutral scale\n    const lightnessScale = {\n        '50': 0.98,\n        '100': 0.94,\n        '200': 0.88,\n        '300': 0.78,\n        '400': 0.66,\n        '500': 0.54,\n        '600': 0.42,\n        '700': 0.32,\n        '800': 0.22,\n        '900': 0.14,\n        '950': 0.09\n    };\n    const neutralScale = {};\n    // Generate each step in the scale\n    Object.entries(lightnessScale).forEach((param)=>{\n        let [step, lightness] = param;\n        // Adjust saturation based on lightness\n        // Very dark and very light colors get even less saturation\n        let adjustedSaturation = baseSaturation;\n        if (lightness > 0.9 || lightness < 0.2) {\n            adjustedSaturation = baseSaturation * 0.5;\n        }\n        const color = hslToRgb(neutralHue, adjustedSaturation, lightness);\n        neutralScale[step] = rgbToHex(color.r, color.g, color.b);\n    });\n    return neutralScale;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9jb2xvclV0aWxzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztDQUVDLEdBQ00sU0FBU0EsU0FBU0MsR0FBVztJQUNsQyw2QkFBNkI7SUFDN0JBLE1BQU1BLElBQUlDLE9BQU8sQ0FBQyxNQUFNO0lBRXhCLHNCQUFzQjtJQUN0QixJQUFJQyxHQUFHQyxHQUFHQztJQUNWLElBQUlKLElBQUlLLE1BQU0sS0FBSyxHQUFHO1FBQ3BCSCxJQUFJSSxTQUFTTixHQUFHLENBQUMsRUFBRSxHQUFHQSxHQUFHLENBQUMsRUFBRSxFQUFFO1FBQzlCRyxJQUFJRyxTQUFTTixHQUFHLENBQUMsRUFBRSxHQUFHQSxHQUFHLENBQUMsRUFBRSxFQUFFO1FBQzlCSSxJQUFJRSxTQUFTTixHQUFHLENBQUMsRUFBRSxHQUFHQSxHQUFHLENBQUMsRUFBRSxFQUFFO0lBQ2hDLE9BQU87UUFDTEUsSUFBSUksU0FBU04sSUFBSU8sU0FBUyxDQUFDLEdBQUcsSUFBSTtRQUNsQ0osSUFBSUcsU0FBU04sSUFBSU8sU0FBUyxDQUFDLEdBQUcsSUFBSTtRQUNsQ0gsSUFBSUUsU0FBU04sSUFBSU8sU0FBUyxDQUFDLEdBQUcsSUFBSTtJQUNwQztJQUVBLE9BQU87UUFBRUw7UUFBR0M7UUFBR0M7SUFBRTtBQUNuQjtBQUVBOztDQUVDLEdBQ00sU0FBU0ksU0FBU04sQ0FBUyxFQUFFQyxDQUFTLEVBQUVDLENBQVM7SUFDdEQsT0FBTyxNQUFNLENBQUMsQ0FBQyxLQUFLLEVBQUMsSUFBTUYsQ0FBQUEsS0FBSyxFQUFDLElBQU1DLENBQUFBLEtBQUssS0FBS0MsQ0FBQUEsRUFBR0ssUUFBUSxDQUFDLElBQUlDLEtBQUssQ0FBQztBQUN6RTtBQUVBOztDQUVDLEdBQ00sU0FBU0MsU0FDZFQsQ0FBUyxFQUNUQyxDQUFTLEVBQ1RDLENBQVM7SUFFVEYsS0FBSztJQUNMQyxLQUFLO0lBQ0xDLEtBQUs7SUFFTCxNQUFNUSxNQUFNQyxLQUFLRCxH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O1FBQ0wseUVBQXlFO1FBQ3pFQSxhQUFhLENBQUNBLGFBQWEsSUFBRyxJQUFLLEdBQUcsd0JBQXdCO0lBQ2hFO0lBRUEsMkVBQTJFO0lBQzNFLE1BQU1DLGlCQUFpQjdCLEtBQUtDLEdBQUcsQ0FBQyxNQUFNYyxJQUFJWixDQUFDLEdBQUc7SUFFOUMsNkRBQTZEO0lBQzdELE1BQU1hLGlCQUFpQjtRQUNyQixNQUFNO1FBQ04sT0FBTztRQUNQLE9BQU87UUFDUCxPQUFPO1FBQ1AsT0FBTztRQUNQLE9BQU87UUFDUCxPQUFPO1FBQ1AsT0FBTztRQUNQLE9BQU87UUFDUCxPQUFPO1FBQ1AsT0FBTztJQUNUO0lBRUEsTUFBTWMsZUFBdUMsQ0FBQztJQUU5QyxrQ0FBa0M7SUFDbENYLE9BQU9DLE9BQU8sQ0FBQ0osZ0JBQWdCSyxPQUFPLENBQUM7WUFBQyxDQUFDQyxNQUFNQyxVQUFVO1FBQ3ZELHVDQUF1QztRQUN2QywyREFBMkQ7UUFDM0QsSUFBSUMscUJBQXFCSztRQUN6QixJQUFJTixZQUFZLE9BQU9BLFlBQVksS0FBSztZQUN0Q0MscUJBQXFCSyxpQkFBaUI7UUFDeEM7UUFFQSxNQUFNSixRQUFRbkIsU0FBU3NCLFlBQVlKLG9CQUFvQkQ7UUFDdkRPLFlBQVksQ0FBQ1IsS0FBSyxHQUFHM0IsU0FBUzhCLE1BQU1wQyxDQUFDLEVBQUVvQyxNQUFNbkMsQ0FBQyxFQUFFbUMsTUFBTWxDLENBQUM7SUFDekQ7SUFFQSxPQUFPdUM7QUFDVCIsInNvdXJjZXMiOlsiL1VzZXJzL25hdGUvcHJvamVjdHMvZGVzaWduLXN5c3RlbS1idWlsZGVyL3NyYy91dGlscy9jb2xvclV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ29udmVydHMgYSBoZXggY29sb3IgdG8gUkdCIGNvbXBvbmVudHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvUmdiKGhleDogc3RyaW5nKTogeyByOiBudW1iZXI7IGc6IG51bWJlcjsgYjogbnVtYmVyIH0ge1xuICAvLyBSZW1vdmUgdGhlIGhhc2ggaWYgcHJlc2VudFxuICBoZXggPSBoZXgucmVwbGFjZSgvXiMvLCAnJyk7XG5cbiAgLy8gUGFyc2UgdGhlIGhleCB2YWx1ZVxuICBsZXQgciwgZywgYjtcbiAgaWYgKGhleC5sZW5ndGggPT09IDMpIHtcbiAgICByID0gcGFyc2VJbnQoaGV4WzBdICsgaGV4WzBdLCAxNik7XG4gICAgZyA9IHBhcnNlSW50KGhleFsxXSArIGhleFsxXSwgMTYpO1xuICAgIGIgPSBwYXJzZUludChoZXhbMl0gKyBoZXhbMl0sIDE2KTtcbiAgfSBlbHNlIHtcbiAgICByID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZygwLCAyKSwgMTYpO1xuICAgIGcgPSBwYXJzZUludChoZXguc3Vic3RyaW5nKDIsIDQpLCAxNik7XG4gICAgYiA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoNCwgNiksIDE2KTtcbiAgfVxuXG4gIHJldHVybiB7IHIsIGcsIGIgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBSR0IgY29tcG9uZW50cyB0byBhIGhleCBjb2xvclxuICovXG5leHBvcnQgZnVuY3Rpb24gcmdiVG9IZXgocjogbnVtYmVyLCBnOiBudW1iZXIsIGI6IG51bWJlcik6IHN0cmluZyB7XG4gIHJldHVybiAnIycgKyAoKDEgPDwgMjQpICsgKHIgPDwgMTYpICsgKGcgPDwgOCkgKyBiKS50b1N0cmluZygxNikuc2xpY2UoMSk7XG59XG5cbi8qKlxuICogQ29udmVydHMgUkdCIHRvIEhTTCBjb21wb25lbnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZ2JUb0hzbChcbiAgcjogbnVtYmVyLFxuICBnOiBudW1iZXIsXG4gIGI6IG51bWJlclxuKTogeyBoOiBudW1iZXI7IHM6IG51bWJlcjsgbDogbnVtYmVyIH0ge1xuICByIC89IDI1NTtcbiAgZyAvPSAyNTU7XG4gIGIgLz0gMjU1O1xuXG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICBjb25zdCBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgbGV0IGggPSAwO1xuICBsZXQgcyA9IDA7XG4gIGNvbnN0IGwgPSAobWF4ICsgbWluKSAvIDI7XG5cbiAgaWYgKG1heCAhPT0gbWluKSB7XG4gICAgY29uc3QgZCA9IG1heCAtIG1pbjtcbiAgICBzID0gbCA+IDAuNSA/IGQgLyAoMiAtIG1heCAtIG1pbikgOiBkIC8gKG1heCArIG1pbik7XG5cbiAgICBzd2l0Y2ggKG1heCkge1xuICAgICAgY2FzZSByOlxuICAgICAgICBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBnOlxuICAgICAgICBoID0gKGIgLSByKSAvIGQgKyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgYjpcbiAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaCAvPSA2O1xuICB9XG5cbiAgcmV0dXJuIHsgaCwgcywgbCB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIEhTTCB0byBSR0IgY29tcG9uZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gaHNsVG9SZ2IoXG4gIGg6IG51bWJlcixcbiAgczogbnVtYmVyLFxuICBsOiBudW1iZXJcbik6IHsgcjogbnVtYmVyOyBnOiBudW1iZXI7IGI6IG51bWJlciB9IHtcbiAgbGV0IHIsIGcsIGI7XG5cbiAgaWYgKHMgPT09IDApIHtcbiAgICByID0gZyA9IGIgPSBsOyAvLyBhY2hyb21hdGljXG4gIH0gZWxzZSB7XG4gICAgY29uc3QgaHVlMnJnYiA9IChwOiBudW1iZXIsIHE6IG51bWJlciwgdDogbnVtYmVyKSA9PiB7XG4gICAgICBpZiAodCA8IDApIHQgKz0gMTtcbiAgICAgIGlmICh0ID4gMSkgdCAtPSAxO1xuICAgICAgaWYgKHQgPCAxIC8gNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gICAgICBpZiAodCA8IDEgLyAyKSByZXR1cm4gcTtcbiAgICAgIGlmICh0IDwgMiAvIDMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICBjb25zdCBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICBjb25zdCBwID0gMiAqIGwgLSBxO1xuXG4gICAgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKTtcbiAgICBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgICBiID0gaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByOiBNYXRoLnJvdW5kKHIgKiAyNTUpLFxuICAgIGc6IE1hdGgucm91bmQoZyAqIDI1NSksXG4gICAgYjogTWF0aC5yb3VuZChiICogMjU1KSxcbiAgfTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBjb2xvciBzY2FsZSBiYXNlZCBvbiBhIGJhc2UgY29sb3JcbiAqIEBwYXJhbSBiYXNlQ29sb3IgLSBUaGUgYmFzZSBjb2xvciBpbiBoZXggZm9ybWF0XG4gKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCBjb2xvciB2YXJpYW50cyBmcm9tIDUwIHRvIDk1MFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVDb2xvclNjYWxlKGJhc2VDb2xvcjogc3RyaW5nKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gIGNvbnN0IHJnYiA9IGhleFRvUmdiKGJhc2VDb2xvcik7XG4gIGNvbnN0IGhzbCA9IHJnYlRvSHNsKHJnYi5yLCByZ2IuZywgcmdiLmIpO1xuXG4gIC8vIERlZmluZSBsaWdodG5lc3MgdmFsdWVzIGZvciBlYWNoIHN0ZXAgaW4gdGhlIHNjYWxlXG4gIGNvbnN0IGxpZ2h0bmVzc1NjYWxlID0ge1xuICAgICc1MCc6IDAuOTcsXG4gICAgJzEwMCc6IDAuOTQsXG4gICAgJzIwMCc6IDAuODYsXG4gICAgJzMwMCc6IDAuNzYsXG4gICAgJzQwMCc6IDAuNjYsXG4gICAgJzUwMCc6IDAuNTYsIC8vIFRoaXMgaXMgY2xvc2VzdCB0byB0aGUgYmFzZSBjb2xvclxuICAgICc2MDAnOiAwLjQ2LFxuICAgICc3MDAnOiAwLjM4LFxuICAgICc4MDAnOiAwLjMsXG4gICAgJzkwMCc6IDAuMjIsXG4gICAgJzk1MCc6IDAuMTQsXG4gIH07XG5cbiAgLy8gQWRqdXN0IHNhdHVyYXRpb24gYmFzZWQgb24gYmFzZSBjb2xvcidzIHNhdHVyYXRpb25cbiAgLy8gRm9yIHZlcnkgbG93IG9yIHZlcnkgaGlnaCBzYXR1cmF0aW9uIGNvbG9ycywgd2UgbmVlZCB0byBhZGp1c3QgdG8gY3JlYXRlIGEgYmFsYW5jZWQgc2NhbGVcbiAgbGV0IHNhdHVyYXRpb25BZGp1c3QgPSAxO1xuICBpZiAoaHNsLnMgPCAwLjE1KSB7XG4gICAgc2F0dXJhdGlvbkFkanVzdCA9IDM7IC8vIEJvb3N0IHNhdHVyYXRpb24gZm9yIGdyYXktaXNoIGNvbG9yc1xuICB9IGVsc2UgaWYgKGhzbC5zID4gMC45KSB7XG4gICAgc2F0dXJhdGlvbkFkanVzdCA9IDAuODU7IC8vIFJlZHVjZSBzYXR1cmF0aW9uIGZvciB2ZXJ5IHNhdHVyYXRlZCBjb2xvcnNcbiAgfVxuXG4gIGNvbnN0IGNvbG9yU2NhbGU6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcblxuICAvLyBHZW5lcmF0ZSBlYWNoIHN0ZXAgaW4gdGhlIHNjYWxlXG4gIE9iamVjdC5lbnRyaWVzKGxpZ2h0bmVzc1NjYWxlKS5mb3JFYWNoKChbc3RlcCwgbGlnaHRuZXNzXSkgPT4ge1xuICAgIC8vIEFkanVzdCBzYXR1cmF0aW9uIGJhc2VkIG9uIGxpZ2h0bmVzc1xuICAgIC8vIExpZ2h0ZXIgY29sb3JzIHNob3VsZCBiZSBsZXNzIHNhdHVyYXRlZCwgZGFya2VyIGNvbG9ycyBtb3JlIHNhdHVyYXRlZFxuICAgIGxldCBhZGp1c3RlZFNhdHVyYXRpb24gPSBoc2wucztcbiAgICBpZiAobGlnaHRuZXNzID4gMC43KSB7XG4gICAgICBhZGp1c3RlZFNhdHVyYXRpb24gPSBNYXRoLm1pbigxLCBoc2wucyAqIDAuOCAqIHNhdHVyYXRpb25BZGp1c3QpO1xuICAgIH0gZWxzZSBpZiAobGlnaHRuZXNzIDwgMC4zKSB7XG4gICAgICBhZGp1c3RlZFNhdHVyYXRpb24gPSBNYXRoLm1pbigxLCBoc2wucyAqIDEuMiAqIHNhdHVyYXRpb25BZGp1c3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGp1c3RlZFNhdHVyYXRpb24gPSBNYXRoLm1pbigxLCBoc2wucyAqIHNhdHVyYXRpb25BZGp1c3QpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbG9yID0gaHNsVG9SZ2IoaHNsLmgsIGFkanVzdGVkU2F0dXJhdGlvbiwgbGlnaHRuZXNzKTtcbiAgICBjb2xvclNjYWxlW3N0ZXBdID0gcmdiVG9IZXgoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gIH0pO1xuXG4gIHJldHVybiBjb2xvclNjYWxlO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHNldCBvZiBuZXV0cmFsL2dyZXkgY29sb3JzIHRoYXQgYXJlIGRlcml2ZWQgZnJvbSB0aGUgcHJpbWFyeSBjb2xvclxuICogQHBhcmFtIHByaW1hcnlDb2xvciAtIFRoZSBwcmltYXJ5IGNvbG9yIGluIGhleCBmb3JtYXRcbiAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIG5ldXRyYWwgY29sb3IgdmFyaWFudHMgZnJvbSA1MCB0byA5NTBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlTmV1dHJhbHMocHJpbWFyeUNvbG9yOiBzdHJpbmcpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgY29uc3QgcmdiID0gaGV4VG9SZ2IocHJpbWFyeUNvbG9yKTtcbiAgY29uc3QgaHNsID0gcmdiVG9Ic2wocmdiLnIsIHJnYi5nLCByZ2IuYik7XG5cbiAgLy8gRGVyaXZlIGEgbmV1dHJhbCBwYWxldHRlIGJ5OlxuICAvLyAxLiBUYWtpbmcgdGhlIGh1ZSBmcm9tIHRoZSBwcmltYXJ5IGNvbG9yXG4gIC8vIDIuIFNpZ25pZmljYW50bHkgcmVkdWNpbmcgdGhlIHNhdHVyYXRpb25cbiAgLy8gMy4gVXNpbmcgYSBzaW1pbGFyIGxpZ2h0bmVzcyBzY2FsZSBhcyB0aGUgY29sb3Igc2NhbGVcblxuICAvLyBDcmVhdGUgYSBzbGlnaHQgaHVlIHNoaWZ0IGZvciBtb3JlIGludGVyZXN0aW5nIG5ldXRyYWxzXG4gIC8vIE1vdmUgdGhlIGh1ZSBzbGlnaHRseSB0b3dhcmQgYmx1ZSBmb3IgY29vbCBncmV5cyBvciB0b3dhcmQgb3JhbmdlIGZvciB3YXJtIGdyZXlzXG4gIC8vIEJhc2VkIG9uIHdoZXJlIHRoZSBvcmlnaW5hbCBodWUgaXMgbG9jYXRlZFxuICBsZXQgbmV1dHJhbEh1ZSA9IGhzbC5oO1xuXG4gIC8vIElmIHRoZSBodWUgaXMgaW4gdGhlIGJsdWUvZ3JlZW4gcmFuZ2UsIHNoaWZ0IHRvd2FyZCB3YXJtZXIgZ3JleVxuICBpZiAobmV1dHJhbEh1ZSA+IDAuMyAmJiBuZXV0cmFsSHVlIDwgMC43KSB7XG4gICAgbmV1dHJhbEh1ZSA9IChuZXV0cmFsSHVlICsgMC4wNSkgJSAxOyAvLyBTaGlmdCBzbGlnaHRseSB3YXJtZXJcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGUgaHVlIGlzIGluIHRoZSByZWQvb3JhbmdlL3llbGxvdyByYW5nZSwgc2hpZnQgdG93YXJkIGNvb2xlciBncmV5XG4gICAgbmV1dHJhbEh1ZSA9IChuZXV0cmFsSHVlICsgMC45NSkgJSAxOyAvLyBTaGlmdCBzbGlnaHRseSBjb29sZXJcbiAgfVxuXG4gIC8vIFZlcnkgbG93IHNhdHVyYXRpb24gZm9yIG5ldXRyYWxzLCBidXQga2VlcCBhIGhpbnQgb2YgdGhlIGNvbG9yIGluZmx1ZW5jZVxuICBjb25zdCBiYXNlU2F0dXJhdGlvbiA9IE1hdGgubWluKDAuMDgsIGhzbC5zICogMC4xMik7XG5cbiAgLy8gRGVmaW5lIGxpZ2h0bmVzcyB2YWx1ZXMgZm9yIGVhY2ggc3RlcCBpbiB0aGUgbmV1dHJhbCBzY2FsZVxuICBjb25zdCBsaWdodG5lc3NTY2FsZSA9IHtcbiAgICAnNTAnOiAwLjk4LCAvLyBOZWFybHkgd2hpdGVcbiAgICAnMTAwJzogMC45NCxcbiAgICAnMjAwJzogMC44OCxcbiAgICAnMzAwJzogMC43OCxcbiAgICAnNDAwJzogMC42NixcbiAgICAnNTAwJzogMC41NCxcbiAgICAnNjAwJzogMC40MixcbiAgICAnNzAwJzogMC4zMixcbiAgICAnODAwJzogMC4yMixcbiAgICAnOTAwJzogMC4xNCxcbiAgICAnOTUwJzogMC4wOSwgLy8gTmVhcmx5IGJsYWNrXG4gIH07XG5cbiAgY29uc3QgbmV1dHJhbFNjYWxlOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgLy8gR2VuZXJhdGUgZWFjaCBzdGVwIGluIHRoZSBzY2FsZVxuICBPYmplY3QuZW50cmllcyhsaWdodG5lc3NTY2FsZSkuZm9yRWFjaCgoW3N0ZXAsIGxpZ2h0bmVzc10pID0+IHtcbiAgICAvLyBBZGp1c3Qgc2F0dXJhdGlvbiBiYXNlZCBvbiBsaWdodG5lc3NcbiAgICAvLyBWZXJ5IGRhcmsgYW5kIHZlcnkgbGlnaHQgY29sb3JzIGdldCBldmVuIGxlc3Mgc2F0dXJhdGlvblxuICAgIGxldCBhZGp1c3RlZFNhdHVyYXRpb24gPSBiYXNlU2F0dXJhdGlvbjtcbiAgICBpZiAobGlnaHRuZXNzID4gMC45IHx8IGxpZ2h0bmVzcyA8IDAuMikge1xuICAgICAgYWRqdXN0ZWRTYXR1cmF0aW9uID0gYmFzZVNhdHVyYXRpb24gKiAwLjU7XG4gICAgfVxuXG4gICAgY29uc3QgY29sb3IgPSBoc2xUb1JnYihuZXV0cmFsSHVlLCBhZGp1c3RlZFNhdHVyYXRpb24sIGxpZ2h0bmVzcyk7XG4gICAgbmV1dHJhbFNjYWxlW3N0ZXBdID0gcmdiVG9IZXgoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gIH0pO1xuXG4gIHJldHVybiBuZXV0cmFsU2NhbGU7XG59XG4iXSwibmFtZXMiOlsiaGV4VG9SZ2IiLCJoZXgiLCJyZXBsYWNlIiwiciIsImciLCJiIiwibGVuZ3RoIiwicGFyc2VJbnQiLCJzdWJzdHJpbmciLCJyZ2JUb0hleCIsInRvU3RyaW5nIiwic2xpY2UiLCJyZ2JUb0hzbCIsIm1heCIsIk1hdGgiLCJtaW4iLCJoIiwicyIsImwiLCJkIiwiaHNsVG9SZ2IiLCJodWUycmdiIiwicCIsInEiLCJ0Iiwicm91bmQiLCJnZW5lcmF0ZUNvbG9yU2NhbGUiLCJiYXNlQ29sb3IiLCJyZ2IiLCJoc2wiLCJsaWdodG5lc3NTY2FsZSIsInNhdHVyYXRpb25BZGp1c3QiLCJjb2xvclNjYWxlIiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJzdGVwIiwibGlnaHRuZXNzIiwiYWRqdXN0ZWRTYXR1cmF0aW9uIiwiY29sb3IiLCJnZW5lcmF0ZU5ldXRyYWxzIiwicHJpbWFyeUNvbG9yIiwibmV1dHJhbEh1ZSIsImJhc2VTYXR1cmF0aW9uIiwibmV1dHJhbFNjYWxlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/colorUtils.ts\n"));

/***/ })

});