/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fnate%2Fprojects%2Fdesign-system-builder%2Fsrc%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fnate%2Fprojects%2Fdesign-system-builder%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%2Fapp%2Flayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Inter%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22inter%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fnate%2Fprojects%2Fdesign-system-builder%2Fsrc%2Fcontext%2FDesignSystemContext.tsx%22%2C%22ids%22%3A%5B%22DesignSystemProvider%22%5D%7D&server=false!":
/*!**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fnate%2Fprojects%2Fdesign-system-builder%2Fsrc%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fnate%2Fprojects%2Fdesign-system-builder%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%2Fapp%2Flayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Inter%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22inter%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fnate%2Fprojects%2Fdesign-system-builder%2Fsrc%2Fcontext%2FDesignSystemContext.tsx%22%2C%22ids%22%3A%5B%22DesignSystemProvider%22%5D%7D&server=false! ***!
  \**************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/globals.css */ \"(app-pages-browser)/./src/app/globals.css\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/font/google/target.css?{\"path\":\"src/app/layout.tsx\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"inter\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"src/app/layout.tsx\\\",\\\"import\\\":\\\"Inter\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"]}],\\\"variableName\\\":\\\"inter\\\"}\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/context/DesignSystemContext.tsx */ \"(app-pages-browser)/./src/context/DesignSystemContext.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZuYXRlJTJGcHJvamVjdHMlMkZkZXNpZ24tc3lzdGVtLWJ1aWxkZXIlMkZzcmMlMkZhcHAlMkZnbG9iYWxzLmNzcyUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjIlMkZVc2VycyUyRm5hdGUlMkZwcm9qZWN0cyUyRmRlc2lnbi1zeXN0ZW0tYnVpbGRlciUyRm5vZGVfbW9kdWxlcyUyRm5leHQlMkZmb250JTJGZ29vZ2xlJTJGdGFyZ2V0LmNzcyUzRiU3QiU1QyUyMnBhdGglNUMlMjIlM0ElNUMlMjJzcmMlMkZhcHAlMkZsYXlvdXQudHN4JTVDJTIyJTJDJTVDJTIyaW1wb3J0JTVDJTIyJTNBJTVDJTIySW50ZXIlNUMlMjIlMkMlNUMlMjJhcmd1bWVudHMlNUMlMjIlM0ElNUIlN0IlNUMlMjJzdWJzZXRzJTVDJTIyJTNBJTVCJTVDJTIybGF0aW4lNUMlMjIlNUQlN0QlNUQlMkMlNUMlMjJ2YXJpYWJsZU5hbWUlNUMlMjIlM0ElNUMlMjJpbnRlciU1QyUyMiU3RCUyMiUyQyUyMmlkcyUyMiUzQSU1QiU1RCU3RCZtb2R1bGVzPSU3QiUyMnJlcXVlc3QlMjIlM0ElMjIlMkZVc2VycyUyRm5hdGUlMkZwcm9qZWN0cyUyRmRlc2lnbi1zeXN0ZW0tYnVpbGRlciUyRnNyYyUyRmNvbnRleHQlMkZEZXNpZ25TeXN0ZW1Db250ZXh0LnRzeCUyMiUyQyUyMmlkcyUyMiUzQSU1QiUyMkRlc2lnblN5c3RlbVByb3ZpZGVyJTIyJTVEJTdEJnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEsb0tBQW1HO0FBQ25HO0FBQ0EsMGJBQW9QO0FBQ3BQO0FBQ0Esb01BQTZKIiwic291cmNlcyI6WyIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvbmF0ZS9wcm9qZWN0cy9kZXNpZ24tc3lzdGVtLWJ1aWxkZXIvc3JjL2FwcC9nbG9iYWxzLmNzc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiL1VzZXJzL25hdGUvcHJvamVjdHMvZGVzaWduLXN5c3RlbS1idWlsZGVyL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1xcXCJwYXRoXFxcIjpcXFwic3JjL2FwcC9sYXlvdXQudHN4XFxcIixcXFwiaW1wb3J0XFxcIjpcXFwiSW50ZXJcXFwiLFxcXCJhcmd1bWVudHNcXFwiOlt7XFxcInN1YnNldHNcXFwiOltcXFwibGF0aW5cXFwiXX1dLFxcXCJ2YXJpYWJsZU5hbWVcXFwiOlxcXCJpbnRlclxcXCJ9XCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJEZXNpZ25TeXN0ZW1Qcm92aWRlclwiXSAqLyBcIi9Vc2Vycy9uYXRlL3Byb2plY3RzL2Rlc2lnbi1zeXN0ZW0tYnVpbGRlci9zcmMvY29udGV4dC9EZXNpZ25TeXN0ZW1Db250ZXh0LnRzeFwiKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fnate%2Fprojects%2Fdesign-system-builder%2Fsrc%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fnate%2Fprojects%2Fdesign-system-builder%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%2Fapp%2Flayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Inter%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22inter%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fnate%2Fprojects%2Fdesign-system-builder%2Fsrc%2Fcontext%2FDesignSystemContext.tsx%22%2C%22ids%22%3A%5B%22DesignSystemProvider%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(()=>{\"use strict\";var e={529:(e,r,t)=>{var n=t(191);var i=Object.create(null);var a=typeof document===\"undefined\";var o=Array.prototype.forEach;function debounce(e,r){var t=0;return function(){var n=this;var i=arguments;var a=function functionCall(){return e.apply(n,i)};clearTimeout(t);t=setTimeout(a,r)}}function noop(){}function getCurrentScriptUrl(e){var r=i[e];if(!r){if(document.currentScript){r=document.currentScript.src}else{var t=document.getElementsByTagName(\"script\");var a=t[t.length-1];if(a){r=a.src}}i[e]=r}return function(e){if(!r){return null}var t=r.split(/([^\\\\/]+)\\.js$/);var i=t&&t[1];if(!i){return[r.replace(\".js\",\".css\")]}if(!e){return[r.replace(\".js\",\".css\")]}return e.split(\",\").map((function(e){var t=new RegExp(\"\".concat(i,\"\\\\.js$\"),\"g\");return n(r.replace(t,\"\".concat(e.replace(/{fileName}/g,i),\".css\")))}))}}function updateCss(e,r){if(!r){if(!e.href){return}r=e.href.split(\"?\")[0]}if(!isUrlRequest(r)){return}if(e.isLoaded===false){return}if(!r||!(r.indexOf(\".css\")>-1)){return}e.visited=true;var t=e.cloneNode();t.isLoaded=false;t.addEventListener(\"load\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.addEventListener(\"error\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.href=\"\".concat(r,\"?\").concat(Date.now());if(e.nextSibling){e.parentNode.insertBefore(t,e.nextSibling)}else{e.parentNode.appendChild(t)}}function getReloadUrl(e,r){var t;e=n(e,{stripWWW:false});r.some((function(n){if(e.indexOf(r)>-1){t=n}}));return t}function reloadStyle(e){if(!e){return false}var r=document.querySelectorAll(\"link\");var t=false;o.call(r,(function(r){if(!r.href){return}var n=getReloadUrl(r.href,e);if(!isUrlRequest(n)){return}if(r.visited===true){return}if(n){updateCss(r,n);t=true}}));return t}function reloadAll(){var e=document.querySelectorAll(\"link\");o.call(e,(function(e){if(e.visited===true){return}updateCss(e)}))}function isUrlRequest(e){if(!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)){return false}return true}e.exports=function(e,r){if(a){console.log(\"no window.document found, will not HMR CSS\");return noop}var t=getCurrentScriptUrl(e);function update(){var e=t(r.filename);var n=reloadStyle(e);if(r.locals){console.log(\"[HMR] Detected local css modules. Reload all css\");reloadAll();return}if(n){console.log(\"[HMR] css reload %s\",e.join(\" \"))}else{console.log(\"[HMR] Reload all css\");reloadAll()}}return debounce(update,50)}},191:e=>{function normalizeUrl(e){return e.reduce((function(e,r){switch(r){case\"..\":e.pop();break;case\".\":break;default:e.push(r)}return e}),[]).join(\"/\")}e.exports=function(e){e=e.trim();if(/^data:/i.test(e)){return e}var r=e.indexOf(\"//\")!==-1?e.split(\"//\")[0]+\"//\":\"\";var t=e.replace(new RegExp(r,\"i\"),\"\").split(\"/\");var n=t[0].toLowerCase().replace(/\\.$/,\"\");t[0]=\"\";var i=normalizeUrl(t);return r+n+i}}};var r={};function __nccwpck_require__(t){var n=r[t];if(n!==undefined){return n.exports}var i=r[t]={exports:{}};var a=true;try{e[t](i,i.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(529);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLGFBQWEsT0FBTyxjQUFjLGFBQWEsMEJBQTBCLG9DQUFvQyw4QkFBOEIsdUJBQXVCLFFBQVEsa0JBQWtCLFdBQVcsZ0JBQWdCLDhCQUE4QixxQkFBcUIsZ0JBQWdCLG1CQUFtQixpQkFBaUIsZ0NBQWdDLFdBQVcsT0FBTywyQkFBMkIsNkJBQTZCLEtBQUssOENBQThDLG9CQUFvQixNQUFNLFNBQVMsT0FBTyxtQkFBbUIsT0FBTyxZQUFZLGdDQUFnQyxjQUFjLE9BQU8sZ0NBQWdDLE9BQU8sZ0NBQWdDLHFDQUFxQyw0Q0FBNEMsMkNBQTJDLFNBQVMsZ0JBQWdCLElBQUksd0JBQXdCLE9BQU8sWUFBWSxPQUFPLHVCQUF1QixxQkFBcUIsT0FBTyx1QkFBdUIsT0FBTyxnQ0FBZ0MsT0FBTyxlQUFlLG9CQUFvQixpQkFBaUIsc0NBQXNDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsdUNBQXVDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsMkNBQTJDLGtCQUFrQiwyQ0FBMkMsS0FBSyw2QkFBNkIsMkJBQTJCLE1BQU0sT0FBTyxlQUFlLEVBQUUsb0JBQW9CLG9CQUFvQixLQUFLLEdBQUcsU0FBUyx3QkFBd0IsT0FBTyxhQUFhLHdDQUF3QyxZQUFZLHNCQUFzQixZQUFZLE9BQU8sNkJBQTZCLHFCQUFxQixPQUFPLHFCQUFxQixPQUFPLE1BQU0sZUFBZSxRQUFRLEdBQUcsU0FBUyxxQkFBcUIsd0NBQXdDLHNCQUFzQixxQkFBcUIsT0FBTyxhQUFhLEdBQUcseUJBQXlCLHlDQUF5QyxhQUFhLFlBQVksd0JBQXdCLE1BQU0sMERBQTBELFlBQVksNkJBQTZCLGtCQUFrQixvQkFBb0IscUJBQXFCLGFBQWEsZ0VBQWdFLFlBQVksT0FBTyxNQUFNLCtDQUErQyxLQUFLLG9DQUFvQyxhQUFhLDRCQUE0QixTQUFTLHlCQUF5QiwrQkFBK0IsVUFBVSxpQkFBaUIsTUFBTSxjQUFjLGtCQUFrQixTQUFTLGdCQUFnQixzQkFBc0IsV0FBVyxzQkFBc0IsU0FBUyxvREFBb0QsaURBQWlELDJDQUEyQyxRQUFRLHNCQUFzQixnQkFBZ0IsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsiL1VzZXJzL25hdGUvcHJvamVjdHMvZGVzaWduLXN5c3RlbS1idWlsZGVyL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXs1Mjk6KGUscix0KT0+e3ZhciBuPXQoMTkxKTt2YXIgaT1PYmplY3QuY3JlYXRlKG51bGwpO3ZhciBhPXR5cGVvZiBkb2N1bWVudD09PVwidW5kZWZpbmVkXCI7dmFyIG89QXJyYXkucHJvdG90eXBlLmZvckVhY2g7ZnVuY3Rpb24gZGVib3VuY2UoZSxyKXt2YXIgdD0wO3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXM7dmFyIGk9YXJndW1lbnRzO3ZhciBhPWZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbCgpe3JldHVybiBlLmFwcGx5KG4saSl9O2NsZWFyVGltZW91dCh0KTt0PXNldFRpbWVvdXQoYSxyKX19ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0VXJsKGUpe3ZhciByPWlbZV07aWYoIXIpe2lmKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3I9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmN9ZWxzZXt2YXIgdD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTt2YXIgYT10W3QubGVuZ3RoLTFdO2lmKGEpe3I9YS5zcmN9fWlbZV09cn1yZXR1cm4gZnVuY3Rpb24oZSl7aWYoIXIpe3JldHVybiBudWxsfXZhciB0PXIuc3BsaXQoLyhbXlxcXFwvXSspXFwuanMkLyk7dmFyIGk9dCYmdFsxXTtpZighaSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19aWYoIWUpe3JldHVybltyLnJlcGxhY2UoXCIuanNcIixcIi5jc3NcIildfXJldHVybiBlLnNwbGl0KFwiLFwiKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBSZWdFeHAoXCJcIi5jb25jYXQoaSxcIlxcXFwuanMkXCIpLFwiZ1wiKTtyZXR1cm4gbihyLnJlcGxhY2UodCxcIlwiLmNvbmNhdChlLnJlcGxhY2UoL3tmaWxlTmFtZX0vZyxpKSxcIi5jc3NcIikpKX0pKX19ZnVuY3Rpb24gdXBkYXRlQ3NzKGUscil7aWYoIXIpe2lmKCFlLmhyZWYpe3JldHVybn1yPWUuaHJlZi5zcGxpdChcIj9cIilbMF19aWYoIWlzVXJsUmVxdWVzdChyKSl7cmV0dXJufWlmKGUuaXNMb2FkZWQ9PT1mYWxzZSl7cmV0dXJufWlmKCFyfHwhKHIuaW5kZXhPZihcIi5jc3NcIik+LTEpKXtyZXR1cm59ZS52aXNpdGVkPXRydWU7dmFyIHQ9ZS5jbG9uZU5vZGUoKTt0LmlzTG9hZGVkPWZhbHNlO3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoZnVuY3Rpb24oKXtpZih0LmlzTG9hZGVkKXtyZXR1cm59dC5pc0xvYWRlZD10cnVlO2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX0pKTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuaHJlZj1cIlwiLmNvbmNhdChyLFwiP1wiKS5jb25jYXQoRGF0ZS5ub3coKSk7aWYoZS5uZXh0U2libGluZyl7ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LGUubmV4dFNpYmxpbmcpfWVsc2V7ZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHQpfX1mdW5jdGlvbiBnZXRSZWxvYWRVcmwoZSxyKXt2YXIgdDtlPW4oZSx7c3RyaXBXV1c6ZmFsc2V9KTtyLnNvbWUoKGZ1bmN0aW9uKG4pe2lmKGUuaW5kZXhPZihyKT4tMSl7dD1ufX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRTdHlsZShlKXtpZighZSl7cmV0dXJuIGZhbHNlfXZhciByPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rXCIpO3ZhciB0PWZhbHNlO28uY2FsbChyLChmdW5jdGlvbihyKXtpZighci5ocmVmKXtyZXR1cm59dmFyIG49Z2V0UmVsb2FkVXJsKHIuaHJlZixlKTtpZighaXNVcmxSZXF1ZXN0KG4pKXtyZXR1cm59aWYoci52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufWlmKG4pe3VwZGF0ZUNzcyhyLG4pO3Q9dHJ1ZX19KSk7cmV0dXJuIHR9ZnVuY3Rpb24gcmVsb2FkQWxsKCl7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7by5jYWxsKGUsKGZ1bmN0aW9uKGUpe2lmKGUudmlzaXRlZD09PXRydWUpe3JldHVybn11cGRhdGVDc3MoZSl9KSl9ZnVuY3Rpb24gaXNVcmxSZXF1ZXN0KGUpe2lmKCEvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo6Ly50ZXN0KGUpKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9ZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7aWYoYSl7Y29uc29sZS5sb2coXCJubyB3aW5kb3cuZG9jdW1lbnQgZm91bmQsIHdpbGwgbm90IEhNUiBDU1NcIik7cmV0dXJuIG5vb3B9dmFyIHQ9Z2V0Q3VycmVudFNjcmlwdFVybChlKTtmdW5jdGlvbiB1cGRhdGUoKXt2YXIgZT10KHIuZmlsZW5hbWUpO3ZhciBuPXJlbG9hZFN0eWxlKGUpO2lmKHIubG9jYWxzKXtjb25zb2xlLmxvZyhcIltITVJdIERldGVjdGVkIGxvY2FsIGNzcyBtb2R1bGVzLiBSZWxvYWQgYWxsIGNzc1wiKTtyZWxvYWRBbGwoKTtyZXR1cm59aWYobil7Y29uc29sZS5sb2coXCJbSE1SXSBjc3MgcmVsb2FkICVzXCIsZS5qb2luKFwiIFwiKSl9ZWxzZXtjb25zb2xlLmxvZyhcIltITVJdIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpfX1yZXR1cm4gZGVib3VuY2UodXBkYXRlLDUwKX19LDE5MTplPT57ZnVuY3Rpb24gbm9ybWFsaXplVXJsKGUpe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXtzd2l0Y2gocil7Y2FzZVwiLi5cIjplLnBvcCgpO2JyZWFrO2Nhc2VcIi5cIjpicmVhaztkZWZhdWx0OmUucHVzaChyKX1yZXR1cm4gZX0pLFtdKS5qb2luKFwiL1wiKX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSl7ZT1lLnRyaW0oKTtpZigvXmRhdGE6L2kudGVzdChlKSl7cmV0dXJuIGV9dmFyIHI9ZS5pbmRleE9mKFwiLy9cIikhPT0tMT9lLnNwbGl0KFwiLy9cIilbMF0rXCIvL1wiOlwiXCI7dmFyIHQ9ZS5yZXBsYWNlKG5ldyBSZWdFeHAocixcImlcIiksXCJcIikuc3BsaXQoXCIvXCIpO3ZhciBuPXRbMF0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC4kLyxcIlwiKTt0WzBdPVwiXCI7dmFyIGk9bm9ybWFsaXplVXJsKHQpO3JldHVybiByK24raX19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBuPXJbdF07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNTI5KTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function getTaskName(type) {\n      if (type === REACT_FRAGMENT_TYPE) return \"<>\";\n      if (\n        \"object\" === typeof type &&\n        null !== type &&\n        type.$$typeof === REACT_LAZY_TYPE\n      )\n        return \"<...>\";\n      try {\n        var name = getComponentNameFromType(type);\n        return name ? \"<\" + name + \">\" : \"<...>\";\n      } catch (x) {\n        return \"<...>\";\n      }\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(\n      type,\n      key,\n      self,\n      source,\n      owner,\n      props,\n      debugStack,\n      debugTask\n    ) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.defineProperty(type, \"_debugStack\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugStack\n      });\n      Object.defineProperty(type, \"_debugTask\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: debugTask\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self,\n      debugStack,\n      debugTask\n    ) {\n      var children = config.children;\n      if (void 0 !== children)\n        if (isStaticChildren)\n          if (isArrayImpl(children)) {\n            for (\n              isStaticChildren = 0;\n              isStaticChildren < children.length;\n              isStaticChildren++\n            )\n              validateChildKeys(children[isStaticChildren]);\n            Object.freeze && Object.freeze(children);\n          } else\n            console.error(\n              \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n            );\n        else validateChildKeys(children);\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(\n        type,\n        children,\n        self,\n        source,\n        getOwner(),\n        maybeKey,\n        debugStack,\n        debugTask\n      );\n    }\n    function validateChildKeys(node) {\n      \"object\" === typeof node &&\n        null !== node &&\n        node.$$typeof === REACT_ELEMENT_TYPE &&\n        node._store &&\n        (node._store.validated = 1);\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      isArrayImpl = Array.isArray;\n    new (\"function\" === typeof WeakMap ? WeakMap : Map)();\n    var createTask = console.createTask\n        ? console.createTask\n        : function () {\n            return null;\n          },\n      specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var didWarnAboutKeySpread = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      return jsxDEVImpl(\n        type,\n        config,\n        maybeKey,\n        isStaticChildren,\n        source,\n        self,\n        Error(\"react-stack-top-frame\"),\n        createTask(getTaskName(type))\n      );\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLCtDQUErQyw2QkFBNkI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHNHQUEwQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLElBQUksZ0JBQWdCO0FBQ3BCLElBQUksY0FBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHIiwic291cmNlcyI6WyIvVXNlcnMvbmF0ZS9wcm9qZWN0cy9kZXNpZ24tc3lzdGVtLWJ1aWxkZXIvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cInByb2R1Y3Rpb25cIiAhPT0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgJiZcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkge1xuICAgICAgaWYgKG51bGwgPT0gdHlwZSkgcmV0dXJuIG51bGw7XG4gICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgdHlwZSlcbiAgICAgICAgcmV0dXJuIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0VcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRUYXNrTmFtZSh0eXBlKSB7XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkgcmV0dXJuIFwiPD5cIjtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgbnVsbCAhPT0gdHlwZSAmJlxuICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEVcbiAgICAgIClcbiAgICAgICAgcmV0dXJuIFwiPC4uLj5cIjtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICByZXR1cm4gbmFtZSA/IFwiPFwiICsgbmFtZSArIFwiPlwiIDogXCI8Li4uPlwiO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICByZXR1cm4gXCI8Li4uPlwiO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRPd25lcigpIHtcbiAgICAgIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICAgIHJldHVybiBudWxsID09PSBkaXNwYXRjaGVyID8gbnVsbCA6IGRpc3BhdGNoZXIuZ2V0T3duZXIoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgXCJrZXlcIikuZ2V0O1xuICAgICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykgcmV0dXJuICExO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gY29uZmlnLmtleTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gICAgICBmdW5jdGlvbiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkoKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIHx8XG4gICAgICAgICAgKChzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9ICEwKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgXCIlczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCBpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lIHZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgcHJvcC4gKGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc3BlY2lhbC1wcm9wcylcIixcbiAgICAgICAgICAgIGRpc3BsYXlOYW1lXG4gICAgICAgICAgKSk7XG4gICAgICB9XG4gICAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSAhMDtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgXCJrZXlcIiwge1xuICAgICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMFxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nKCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodGhpcy50eXBlKTtcbiAgICAgIGRpZFdhcm5BYm91dEVsZW1lbnRSZWZbY29tcG9uZW50TmFtZV0gfHxcbiAgICAgICAgKChkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdID0gITApLFxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiQWNjZXNzaW5nIGVsZW1lbnQucmVmIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiByZWYgaXMgbm93IGEgcmVndWxhciBwcm9wLiBJdCB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgSlNYIEVsZW1lbnQgdHlwZSBpbiBhIGZ1dHVyZSByZWxlYXNlLlwiXG4gICAgICAgICkpO1xuICAgICAgY29tcG9uZW50TmFtZSA9IHRoaXMucHJvcHMucmVmO1xuICAgICAgcmV0dXJuIHZvaWQgMCAhPT0gY29tcG9uZW50TmFtZSA/IGNvbXBvbmVudE5hbWUgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBSZWFjdEVsZW1lbnQoXG4gICAgICB0eXBlLFxuICAgICAga2V5LFxuICAgICAgc2VsZixcbiAgICAgIHNvdXJjZSxcbiAgICAgIG93bmVyLFxuICAgICAgcHJvcHMsXG4gICAgICBkZWJ1Z1N0YWNrLFxuICAgICAgZGVidWdUYXNrXG4gICAgKSB7XG4gICAgICBzZWxmID0gcHJvcHMucmVmO1xuICAgICAgdHlwZSA9IHtcbiAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAga2V5OiBrZXksXG4gICAgICAgIHByb3BzOiBwcm9wcyxcbiAgICAgICAgX293bmVyOiBvd25lclxuICAgICAgfTtcbiAgICAgIG51bGwgIT09ICh2b2lkIDAgIT09IHNlbGYgPyBzZWxmIDogbnVsbClcbiAgICAgICAgPyBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwge1xuICAgICAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgICAgICBnZXQ6IGVsZW1lbnRSZWZHZXR0ZXJXaXRoRGVwcmVjYXRpb25XYXJuaW5nXG4gICAgICAgICAgfSlcbiAgICAgICAgOiBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJyZWZcIiwgeyBlbnVtZXJhYmxlOiAhMSwgdmFsdWU6IG51bGwgfSk7XG4gICAgICB0eXBlLl9zdG9yZSA9IHt9O1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUuX3N0b3JlLCBcInZhbGlkYXRlZFwiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z0luZm9cIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogbnVsbFxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZSwgXCJfZGVidWdTdGFja1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBkZWJ1Z1N0YWNrXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcIl9kZWJ1Z1Rhc2tcIiwge1xuICAgICAgICBjb25maWd1cmFibGU6ICExLFxuICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgd3JpdGFibGU6ICEwLFxuICAgICAgICB2YWx1ZTogZGVidWdUYXNrXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzeERFVkltcGwoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgc291cmNlLFxuICAgICAgc2VsZixcbiAgICAgIGRlYnVnU3RhY2ssXG4gICAgICBkZWJ1Z1Rhc2tcbiAgICApIHtcbiAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgIGlmICh2b2lkIDAgIT09IGNoaWxkcmVuKVxuICAgICAgICBpZiAoaXNTdGF0aWNDaGlsZHJlbilcbiAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID0gMDtcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbisrXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dKTtcbiAgICAgICAgICAgIE9iamVjdC5mcmVlemUgJiYgT2JqZWN0LmZyZWV6ZShjaGlsZHJlbik7XG4gICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICBcIlJlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuIFlvdSBhcmUgbGlrZWx5IGV4cGxpY2l0bHkgY2FsbGluZyBSZWFjdC5qc3hzIG9yIFJlYWN0LmpzeERFVi4gVXNlIHRoZSBCYWJlbCB0cmFuc2Zvcm0gaW5zdGVhZC5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbik7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIFwia2V5XCIpKSB7XG4gICAgICAgIGNoaWxkcmVuID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbmZpZykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgICAgcmV0dXJuIFwia2V5XCIgIT09IGs7XG4gICAgICAgIH0pO1xuICAgICAgICBpc1N0YXRpY0NoaWxkcmVuID1cbiAgICAgICAgICAwIDwga2V5cy5sZW5ndGhcbiAgICAgICAgICAgID8gXCJ7a2V5OiBzb21lS2V5LCBcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiXG4gICAgICAgICAgICA6IFwie2tleTogc29tZUtleX1cIjtcbiAgICAgICAgZGlkV2FybkFib3V0S2V5U3ByZWFkW2NoaWxkcmVuICsgaXNTdGF0aWNDaGlsZHJlbl0gfHxcbiAgICAgICAgICAoKGtleXMgPVxuICAgICAgICAgICAgMCA8IGtleXMubGVuZ3RoID8gXCJ7XCIgKyBrZXlzLmpvaW4oXCI6IC4uLiwgXCIpICsgXCI6IC4uLn1cIiA6IFwie31cIiksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIHsuLi5wcm9wc30gLz5cXG5SZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4gIGxldCBwcm9wcyA9ICVzO1xcbiAgPCVzIGtleT17c29tZUtleX0gey4uLnByb3BzfSAvPicsXG4gICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgICAgICBrZXlzLFxuICAgICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgICApLFxuICAgICAgICAgIChkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSA9ICEwKSk7XG4gICAgICB9XG4gICAgICBjaGlsZHJlbiA9IG51bGw7XG4gICAgICB2b2lkIDAgIT09IG1heWJlS2V5ICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KSwgKGNoaWxkcmVuID0gXCJcIiArIG1heWJlS2V5KSk7XG4gICAgICBoYXNWYWxpZEtleShjb25maWcpICYmXG4gICAgICAgIChjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgY29uZmlnLmtleSkpO1xuICAgICAgaWYgKFwia2V5XCIgaW4gY29uZmlnKSB7XG4gICAgICAgIG1heWJlS2V5ID0ge307XG4gICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGNvbmZpZylcbiAgICAgICAgICBcImtleVwiICE9PSBwcm9wTmFtZSAmJiAobWF5YmVLZXlbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXSk7XG4gICAgICB9IGVsc2UgbWF5YmVLZXkgPSBjb25maWc7XG4gICAgICBjaGlsZHJlbiAmJlxuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihcbiAgICAgICAgICBtYXliZUtleSxcbiAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlXG4gICAgICAgICAgICA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IFwiVW5rbm93blwiXG4gICAgICAgICAgICA6IHR5cGVcbiAgICAgICAgKTtcbiAgICAgIHJldHVybiBSZWFjdEVsZW1lbnQoXG4gICAgICAgIHR5cGUsXG4gICAgICAgIGNoaWxkcmVuLFxuICAgICAgICBzZWxmLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGdldE93bmVyKCksXG4gICAgICAgIG1heWJlS2V5LFxuICAgICAgICBkZWJ1Z1N0YWNrLFxuICAgICAgICBkZWJ1Z1Rhc2tcbiAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUpIHtcbiAgICAgIFwib2JqZWN0XCIgPT09IHR5cGVvZiBub2RlICYmXG4gICAgICAgIG51bGwgIT09IG5vZGUgJiZcbiAgICAgICAgbm9kZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFICYmXG4gICAgICAgIG5vZGUuX3N0b3JlICYmXG4gICAgICAgIChub2RlLl9zdG9yZS52YWxpZGF0ZWQgPSAxKTtcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTtcbiAgICBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik7XG4gICAgdmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPVxuICAgICAgICBSZWFjdC5fX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksXG4gICAgICBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7XG4gICAgbmV3IChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrTWFwID8gV2Vha01hcCA6IE1hcCkoKTtcbiAgICB2YXIgY3JlYXRlVGFzayA9IGNvbnNvbGUuY3JlYXRlVGFza1xuICAgICAgICA/IGNvbnNvbGUuY3JlYXRlVGFza1xuICAgICAgICA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0sXG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bjtcbiAgICB2YXIgZGlkV2FybkFib3V0RWxlbWVudFJlZiA9IHt9O1xuICAgIHZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLmpzeERFViA9IGZ1bmN0aW9uIChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmXG4gICAgKSB7XG4gICAgICByZXR1cm4ganN4REVWSW1wbChcbiAgICAgICAgdHlwZSxcbiAgICAgICAgY29uZmlnLFxuICAgICAgICBtYXliZUtleSxcbiAgICAgICAgaXNTdGF0aWNDaGlsZHJlbixcbiAgICAgICAgc291cmNlLFxuICAgICAgICBzZWxmLFxuICAgICAgICBFcnJvcihcInJlYWN0LXN0YWNrLXRvcC1mcmFtZVwiKSxcbiAgICAgICAgY3JlYXRlVGFzayhnZXRUYXNrTmFtZSh0eXBlKSlcbiAgICAgICk7XG4gICAgfTtcbiAgfSkoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9uYXRlL3Byb2plY3RzL2Rlc2lnbi1zeXN0ZW0tYnVpbGRlci9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"src/app/layout.tsx\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"inter\"}":
/*!************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"src/app/layout.tsx","import":"Inter","arguments":[{"subsets":["latin"]}],"variableName":"inter"} ***!
  \************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'Inter', 'Inter Fallback'\",\"fontStyle\":\"normal\"},\"className\":\"__className_d65c78\"};\n    if(true) {\n      // 1741056663267\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwic3JjL2FwcC9sYXlvdXQudHN4XCIsXCJpbXBvcnRcIjpcIkludGVyXCIsXCJhcmd1bWVudHNcIjpbe1wic3Vic2V0c1wiOltcImxhdGluXCJdfV0sXCJ2YXJpYWJsZU5hbWVcIjpcImludGVyXCJ9IiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0JBQWtCLFNBQVMsOERBQThEO0FBQ3pGLE9BQU8sSUFBVTtBQUNqQjtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHdNQUFnSSxjQUFjLHNEQUFzRDtBQUNsTyxNQUFNLFVBQVU7QUFDaEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbmF0ZS9wcm9qZWN0cy9kZXNpZ24tc3lzdGVtLWJ1aWxkZXIvbm9kZV9tb2R1bGVzL25leHQvZm9udC9nb29nbGUvdGFyZ2V0LmNzcz97XCJwYXRoXCI6XCJzcmMvYXBwL2xheW91dC50c3hcIixcImltcG9ydFwiOlwiSW50ZXJcIixcImFyZ3VtZW50c1wiOlt7XCJzdWJzZXRzXCI6W1wibGF0aW5cIl19XSxcInZhcmlhYmxlTmFtZVwiOlwiaW50ZXJcIn0iXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcInN0eWxlXCI6e1wiZm9udEZhbWlseVwiOlwiJ0ludGVyJywgJ0ludGVyIEZhbGxiYWNrJ1wiLFwiZm9udFN0eWxlXCI6XCJub3JtYWxcIn0sXCJjbGFzc05hbWVcIjpcIl9fY2xhc3NOYW1lX2Q2NWM3OFwifTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNzQxMDU2NjYzMjY3XG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIi9Vc2Vycy9uYXRlL3Byb2plY3RzL2Rlc2lnbi1zeXN0ZW0tYnVpbGRlci9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"src/app/layout.tsx\",\"import\":\"Inter\",\"arguments\":[{\"subsets\":[\"latin\"]}],\"variableName\":\"inter\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/app/globals.css":
/*!*****************************!*\
  !*** ./src/app/globals.css ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"900f0203595c\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9hcHAvZ2xvYmFscy5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvbmF0ZS9wcm9qZWN0cy9kZXNpZ24tc3lzdGVtLWJ1aWxkZXIvc3JjL2FwcC9nbG9iYWxzLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjkwMGYwMjAzNTk1Y1wiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/app/globals.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/context/DesignSystemContext.tsx":
/*!*********************************************!*\
  !*** ./src/context/DesignSystemContext.tsx ***!
  \*********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DesignSystemProvider: () => (/* binding */ DesignSystemProvider),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   useDesignSystem: () => (/* binding */ useDesignSystem)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _utils_colorUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/colorUtils */ \"(app-pages-browser)/./src/utils/colorUtils.ts\");\n/* __next_internal_client_entry_do_not_use__ DesignSystemProvider,useDesignSystem,default auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n// Create context with default values\nconst DesignSystemContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(undefined);\nconst DesignSystemProvider = (param)=>{\n    let { children, initialPrimaryColor = '#3b82f6', initialAccentColor = '#ec4899' } = param;\n    _s();\n    // Base colors\n    const [primaryColor, setPrimaryColor] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialPrimaryColor);\n    const [primaryColorScale, setPrimaryColorScale] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)((0,_utils_colorUtils__WEBPACK_IMPORTED_MODULE_2__.generateColorScale)(initialPrimaryColor));\n    const [accentColor, setAccentColor] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialAccentColor);\n    const [accentColorScale, setAccentColorScale] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)((0,_utils_colorUtils__WEBPACK_IMPORTED_MODULE_2__.generateColorScale)(initialAccentColor));\n    // Neutral color (derived from primary by default)\n    const [neutralColor, setNeutralColor] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialPrimaryColor);\n    const [neutralColorScale, setNeutralColorScale] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)((0,_utils_colorUtils__WEBPACK_IMPORTED_MODULE_2__.generateNeutrals)(initialPrimaryColor));\n    // Curve control points\n    const [lightnessControlPoints, setLightnessControlPoints] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [chromaControlPoints, setChromaControlPoints] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Method to set a base color and update its scale\n    const setBaseColor = (type, color)=>{\n        switch(type){\n            case 'primary':\n                setPrimaryColor(color);\n                // Update primary color scale\n                const primaryScale = lightnessControlPoints.length > 0 || chromaControlPoints.length > 0 ? (0,_utils_colorUtils__WEBPACK_IMPORTED_MODULE_2__.applyColorCurves)(color, lightnessControlPoints, chromaControlPoints) : (0,_utils_colorUtils__WEBPACK_IMPORTED_MODULE_2__.generateColorScale)(color);\n                setPrimaryColorScale(primaryScale);\n                // Also update neutral by default when primary changes\n                setNeutralColor(color);\n                // Generate neutrals based on the primary color\n                const neutralScale = (0,_utils_colorUtils__WEBPACK_IMPORTED_MODULE_2__.generateNeutrals)(color);\n                setNeutralColorScale(neutralScale);\n                break;\n            case 'accent':\n                setAccentColor(color);\n                const accentScale = lightnessControlPoints.length > 0 || chromaControlPoints.length > 0 ? (0,_utils_colorUtils__WEBPACK_IMPORTED_MODULE_2__.applyColorCurves)(color, lightnessControlPoints, chromaControlPoints) : (0,_utils_colorUtils__WEBPACK_IMPORTED_MODULE_2__.generateColorScale)(color);\n                setAccentColorScale(accentScale);\n                break;\n            case 'neutral':\n                setNeutralColor(color);\n                // Generate neutrals based on the selected color\n                const newNeutralScale = (0,_utils_colorUtils__WEBPACK_IMPORTED_MODULE_2__.generateNeutrals)(color);\n                setNeutralColorScale(newNeutralScale);\n                break;\n        }\n    };\n    const value = {\n        primaryColor,\n        setPrimaryColor,\n        primaryColorScale,\n        setPrimaryColorScale,\n        accentColor,\n        setAccentColor,\n        accentColorScale,\n        setAccentColorScale,\n        neutralColor,\n        setNeutralColor,\n        neutralColorScale,\n        setNeutralColorScale,\n        setBaseColor,\n        lightnessControlPoints,\n        setLightnessControlPoints,\n        chromaControlPoints,\n        setChromaControlPoints\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(DesignSystemContext.Provider, {\n        value: value,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/nate/projects/design-system-builder/src/context/DesignSystemContext.tsx\",\n        lineNumber: 157,\n        columnNumber: 5\n    }, undefined);\n};\n_s(DesignSystemProvider, \"AO0Z+GfIAvKU/J4cnSINXoMdRJI=\");\n_c = DesignSystemProvider;\n// Custom hook to use the design system context\nconst useDesignSystem = ()=>{\n    _s1();\n    const context = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(DesignSystemContext);\n    if (context === undefined) {\n        throw new Error('useDesignSystem must be used within a DesignSystemProvider');\n    }\n    return context;\n};\n_s1(useDesignSystem, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (DesignSystemContext);\nvar _c;\n$RefreshReg$(_c, \"DesignSystemProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb250ZXh0L0Rlc2lnblN5c3RlbUNvbnRleHQudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUU4RTtBQU1qRDtBQStCN0IscUNBQXFDO0FBQ3JDLE1BQU1PLG9DQUFzQk4sb0RBQWFBLENBQ3ZDTztBQVVLLE1BQU1DLHVCQUE0RDtRQUFDLEVBQ3hFQyxRQUFRLEVBQ1JDLHNCQUFzQixTQUFTLEVBQy9CQyxxQkFBcUIsU0FBUyxFQUMvQjs7SUFDQyxjQUFjO0lBQ2QsTUFBTSxDQUFDQyxjQUFjQyxnQkFBZ0IsR0FBR1gsK0NBQVFBLENBQVNRO0lBQ3pELE1BQU0sQ0FBQ0ksbUJBQW1CQyxxQkFBcUIsR0FBR2IsK0NBQVFBLENBRXhEQyxxRUFBa0JBLENBQUNPO0lBRXJCLE1BQU0sQ0FBQ00sYUFBYUMsZUFBZSxHQUFHZiwrQ0FBUUEsQ0FBU1M7SUFDdkQsTUFBTSxDQUFDTyxrQkFBa0JDLG9CQUFvQixHQUFHakIsK0NBQVFBLENBRXREQyxxRUFBa0JBLENBQUNRO0lBRXJCLGtEQUFrRDtJQUNsRCxNQUFNLENBQUNTLGNBQWNDLGdCQUFnQixHQUFHbkIsK0NBQVFBLENBQVNRO0lBQ3pELE1BQU0sQ0FBQ1ksbUJBQW1CQyxxQkFBcUIsR0FBR3JCLCtDQUFRQSxDQUV4REcsbUVBQWdCQSxDQUFDSztJQUVuQix1QkFBdUI7SUFDdkIsTUFBTSxDQUFDYyx3QkFBd0JDLDBCQUEwQixHQUFHdkIsK0NBQVFBLENBRWxFLEVBQUU7SUFDSixNQUFNLENBQUN3QixxQkFBcUJDLHVCQUF1QixHQUFHekIsK0NBQVFBLENBRTVELEVBQUU7SUFFSixrREFBa0Q7SUFDbEQsTUFBTTBCLGVBQWUsQ0FDbkJDLE1BQ0FDO1FBRUEsT0FBUUQ7WUFDTixLQUFLO2dCQUNIaEIsZ0JBQWdCaUI7Z0JBRWhCLDZCQUE2QjtnQkFDN0IsTUFBTUMsZUFDSlAsdUJBQXVCUSxNQUFNLEdBQUcsS0FBS04sb0JBQW9CTSxNQUFNLEdBQUcsSUFDOUQ1QixtRUFBZ0JBLENBQ2QwQixPQUNBTix3QkFDQUUsdUJBRUZ2QixxRUFBa0JBLENBQUMyQjtnQkFDekJmLHFCQUFxQmdCO2dCQUVyQixzREFBc0Q7Z0JBQ3REVixnQkFBZ0JTO2dCQUNoQiwrQ0FBK0M7Z0JBQy9DLE1BQU1HLGVBQWU1QixtRUFBZ0JBLENBQUN5QjtnQkFDdENQLHFCQUFxQlU7Z0JBQ3JCO1lBRUYsS0FBSztnQkFDSGhCLGVBQWVhO2dCQUNmLE1BQU1JLGNBQ0pWLHVCQUF1QlEsTUFBTSxHQUFHLEtBQUtOLG9CQUFvQk0sTUFBTSxHQUFHLElBQzlENUIsbUVBQWdCQSxDQUNkMEIsT0FDQU4sd0JBQ0FFLHVCQUVGdkIscUVBQWtCQSxDQUFDMkI7Z0JBQ3pCWCxvQkFBb0JlO2dCQUNwQjtZQUVGLEtBQUs7Z0JBQ0hiLGdCQUFnQlM7Z0JBQ2hCLGdEQUFnRDtnQkFDaEQsTUFBTUssa0JBQWtCOUIsbUVBQWdCQSxDQUFDeUI7Z0JBQ3pDUCxxQkFBcUJZO2dCQUNyQjtRQUNKO0lBQ0Y7SUFFQSxNQUFNQyxRQUFRO1FBQ1p4QjtRQUNBQztRQUNBQztRQUNBQztRQUVBQztRQUNBQztRQUNBQztRQUNBQztRQUVBQztRQUNBQztRQUNBQztRQUNBQztRQUVBSztRQUVBSjtRQUNBQztRQUVBQztRQUNBQztJQUNGO0lBRUEscUJBQ0UsOERBQUNyQixvQkFBb0IrQixRQUFRO1FBQUNELE9BQU9BO2tCQUNsQzNCOzs7Ozs7QUFHUCxFQUFFO0dBN0dXRDtLQUFBQTtBQStHYiwrQ0FBK0M7QUFDeEMsTUFBTThCLGtCQUFrQjs7SUFDN0IsTUFBTUMsVUFBVXRDLGlEQUFVQSxDQUFDSztJQUMzQixJQUFJaUMsWUFBWWhDLFdBQVc7UUFDekIsTUFBTSxJQUFJaUMsTUFDUjtJQUVKO0lBQ0EsT0FBT0Q7QUFDVCxFQUFFO0lBUldEO0FBVWIsaUVBQWVoQyxtQkFBbUJBLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9uYXRlL3Byb2plY3RzL2Rlc2lnbi1zeXN0ZW0tYnVpbGRlci9zcmMvY29udGV4dC9EZXNpZ25TeXN0ZW1Db250ZXh0LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5cbmltcG9ydCBSZWFjdCwgeyBjcmVhdGVDb250ZXh0LCB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgUmVhY3ROb2RlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHtcbiAgZ2VuZXJhdGVDb2xvclNjYWxlLFxuICBhcHBseUNvbG9yQ3VydmVzLFxuICBDdXJ2ZUNvbnRyb2xQb2ludCxcbiAgZ2VuZXJhdGVOZXV0cmFscyxcbn0gZnJvbSAnLi4vdXRpbHMvY29sb3JVdGlscyc7XG5cbi8vIERlZmluZSB0aGUgc2hhcGUgb2Ygb3VyIGRlc2lnbiBzeXN0ZW1cbmludGVyZmFjZSBEZXNpZ25TeXN0ZW1Db250ZXh0VHlwZSB7XG4gIC8vIEJhc2UgY29sb3JzXG4gIHByaW1hcnlDb2xvcjogc3RyaW5nO1xuICBzZXRQcmltYXJ5Q29sb3I6IChjb2xvcjogc3RyaW5nKSA9PiB2b2lkO1xuICBwcmltYXJ5Q29sb3JTY2FsZTogUmVjb3JkPHN0cmluZywgc3RyaW5nPjtcbiAgc2V0UHJpbWFyeUNvbG9yU2NhbGU6IChzY2FsZTogUmVjb3JkPHN0cmluZywgc3RyaW5nPikgPT4gdm9pZDtcblxuICBhY2NlbnRDb2xvcjogc3RyaW5nO1xuICBzZXRBY2NlbnRDb2xvcjogKGNvbG9yOiBzdHJpbmcpID0+IHZvaWQ7XG4gIGFjY2VudENvbG9yU2NhbGU6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIHNldEFjY2VudENvbG9yU2NhbGU6IChzY2FsZTogUmVjb3JkPHN0cmluZywgc3RyaW5nPikgPT4gdm9pZDtcblxuICBuZXV0cmFsQ29sb3I6IHN0cmluZztcbiAgc2V0TmV1dHJhbENvbG9yOiAoY29sb3I6IHN0cmluZykgPT4gdm9pZDtcbiAgbmV1dHJhbENvbG9yU2NhbGU6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIHNldE5ldXRyYWxDb2xvclNjYWxlOiAoc2NhbGU6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pID0+IHZvaWQ7XG5cbiAgLy8gTWV0aG9kIHRvIHNldCBhIGJhc2UgY29sb3IgdGhhdCBoYW5kbGVzIHVwZGF0aW5nIHNjYWxlc1xuICBzZXRCYXNlQ29sb3I6ICh0eXBlOiAncHJpbWFyeScgfCAnYWNjZW50JyB8ICduZXV0cmFsJywgY29sb3I6IHN0cmluZykgPT4gdm9pZDtcblxuICAvLyBDdXJ2ZSBjb250cm9sIHBvaW50c1xuICBsaWdodG5lc3NDb250cm9sUG9pbnRzOiBDdXJ2ZUNvbnRyb2xQb2ludFtdO1xuICBzZXRMaWdodG5lc3NDb250cm9sUG9pbnRzOiAocG9pbnRzOiBDdXJ2ZUNvbnRyb2xQb2ludFtdKSA9PiB2b2lkO1xuXG4gIGNocm9tYUNvbnRyb2xQb2ludHM6IEN1cnZlQ29udHJvbFBvaW50W107XG4gIHNldENocm9tYUNvbnRyb2xQb2ludHM6IChwb2ludHM6IEN1cnZlQ29udHJvbFBvaW50W10pID0+IHZvaWQ7XG59XG5cbi8vIENyZWF0ZSBjb250ZXh0IHdpdGggZGVmYXVsdCB2YWx1ZXNcbmNvbnN0IERlc2lnblN5c3RlbUNvbnRleHQgPSBjcmVhdGVDb250ZXh0PERlc2lnblN5c3RlbUNvbnRleHRUeXBlIHwgdW5kZWZpbmVkPihcbiAgdW5kZWZpbmVkXG4pO1xuXG4vLyBQcm92aWRlciBjb21wb25lbnRcbmludGVyZmFjZSBEZXNpZ25TeXN0ZW1Qcm92aWRlclByb3BzIHtcbiAgY2hpbGRyZW46IFJlYWN0Tm9kZTtcbiAgaW5pdGlhbFByaW1hcnlDb2xvcj86IHN0cmluZztcbiAgaW5pdGlhbEFjY2VudENvbG9yPzogc3RyaW5nO1xufVxuXG5leHBvcnQgY29uc3QgRGVzaWduU3lzdGVtUHJvdmlkZXI6IFJlYWN0LkZDPERlc2lnblN5c3RlbVByb3ZpZGVyUHJvcHM+ID0gKHtcbiAgY2hpbGRyZW4sXG4gIGluaXRpYWxQcmltYXJ5Q29sb3IgPSAnIzNiODJmNicsIC8vIERlZmF1bHQgYmx1ZVxuICBpbml0aWFsQWNjZW50Q29sb3IgPSAnI2VjNDg5OScsIC8vIERlZmF1bHQgcGlua1xufSkgPT4ge1xuICAvLyBCYXNlIGNvbG9yc1xuICBjb25zdCBbcHJpbWFyeUNvbG9yLCBzZXRQcmltYXJ5Q29sb3JdID0gdXNlU3RhdGU8c3RyaW5nPihpbml0aWFsUHJpbWFyeUNvbG9yKTtcbiAgY29uc3QgW3ByaW1hcnlDb2xvclNjYWxlLCBzZXRQcmltYXJ5Q29sb3JTY2FsZV0gPSB1c2VTdGF0ZTxcbiAgICBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gID4oZ2VuZXJhdGVDb2xvclNjYWxlKGluaXRpYWxQcmltYXJ5Q29sb3IpKTtcblxuICBjb25zdCBbYWNjZW50Q29sb3IsIHNldEFjY2VudENvbG9yXSA9IHVzZVN0YXRlPHN0cmluZz4oaW5pdGlhbEFjY2VudENvbG9yKTtcbiAgY29uc3QgW2FjY2VudENvbG9yU2NhbGUsIHNldEFjY2VudENvbG9yU2NhbGVdID0gdXNlU3RhdGU8XG4gICAgUmVjb3JkPHN0cmluZywgc3RyaW5nPlxuICA+KGdlbmVyYXRlQ29sb3JTY2FsZShpbml0aWFsQWNjZW50Q29sb3IpKTtcblxuICAvLyBOZXV0cmFsIGNvbG9yIChkZXJpdmVkIGZyb20gcHJpbWFyeSBieSBkZWZhdWx0KVxuICBjb25zdCBbbmV1dHJhbENvbG9yLCBzZXROZXV0cmFsQ29sb3JdID0gdXNlU3RhdGU8c3RyaW5nPihpbml0aWFsUHJpbWFyeUNvbG9yKTtcbiAgY29uc3QgW25ldXRyYWxDb2xvclNjYWxlLCBzZXROZXV0cmFsQ29sb3JTY2FsZV0gPSB1c2VTdGF0ZTxcbiAgICBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+XG4gID4oZ2VuZXJhdGVOZXV0cmFscyhpbml0aWFsUHJpbWFyeUNvbG9yKSk7XG5cbiAgLy8gQ3VydmUgY29udHJvbCBwb2ludHNcbiAgY29uc3QgW2xpZ2h0bmVzc0NvbnRyb2xQb2ludHMsIHNldExpZ2h0bmVzc0NvbnRyb2xQb2ludHNdID0gdXNlU3RhdGU8XG4gICAgQ3VydmVDb250cm9sUG9pbnRbXVxuICA+KFtdKTtcbiAgY29uc3QgW2Nocm9tYUNvbnRyb2xQb2ludHMsIHNldENocm9tYUNvbnRyb2xQb2ludHNdID0gdXNlU3RhdGU8XG4gICAgQ3VydmVDb250cm9sUG9pbnRbXVxuICA+KFtdKTtcblxuICAvLyBNZXRob2QgdG8gc2V0IGEgYmFzZSBjb2xvciBhbmQgdXBkYXRlIGl0cyBzY2FsZVxuICBjb25zdCBzZXRCYXNlQ29sb3IgPSAoXG4gICAgdHlwZTogJ3ByaW1hcnknIHwgJ2FjY2VudCcgfCAnbmV1dHJhbCcsXG4gICAgY29sb3I6IHN0cmluZ1xuICApID0+IHtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ3ByaW1hcnknOlxuICAgICAgICBzZXRQcmltYXJ5Q29sb3IoY29sb3IpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBwcmltYXJ5IGNvbG9yIHNjYWxlXG4gICAgICAgIGNvbnN0IHByaW1hcnlTY2FsZSA9XG4gICAgICAgICAgbGlnaHRuZXNzQ29udHJvbFBvaW50cy5sZW5ndGggPiAwIHx8IGNocm9tYUNvbnRyb2xQb2ludHMubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyBhcHBseUNvbG9yQ3VydmVzKFxuICAgICAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgICAgIGxpZ2h0bmVzc0NvbnRyb2xQb2ludHMsXG4gICAgICAgICAgICAgICAgY2hyb21hQ29udHJvbFBvaW50c1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IGdlbmVyYXRlQ29sb3JTY2FsZShjb2xvcik7XG4gICAgICAgIHNldFByaW1hcnlDb2xvclNjYWxlKHByaW1hcnlTY2FsZSk7XG5cbiAgICAgICAgLy8gQWxzbyB1cGRhdGUgbmV1dHJhbCBieSBkZWZhdWx0IHdoZW4gcHJpbWFyeSBjaGFuZ2VzXG4gICAgICAgIHNldE5ldXRyYWxDb2xvcihjb2xvcik7XG4gICAgICAgIC8vIEdlbmVyYXRlIG5ldXRyYWxzIGJhc2VkIG9uIHRoZSBwcmltYXJ5IGNvbG9yXG4gICAgICAgIGNvbnN0IG5ldXRyYWxTY2FsZSA9IGdlbmVyYXRlTmV1dHJhbHMoY29sb3IpO1xuICAgICAgICBzZXROZXV0cmFsQ29sb3JTY2FsZShuZXV0cmFsU2NhbGUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnYWNjZW50JzpcbiAgICAgICAgc2V0QWNjZW50Q29sb3IoY29sb3IpO1xuICAgICAgICBjb25zdCBhY2NlbnRTY2FsZSA9XG4gICAgICAgICAgbGlnaHRuZXNzQ29udHJvbFBvaW50cy5sZW5ndGggPiAwIHx8IGNocm9tYUNvbnRyb2xQb2ludHMubGVuZ3RoID4gMFxuICAgICAgICAgICAgPyBhcHBseUNvbG9yQ3VydmVzKFxuICAgICAgICAgICAgICAgIGNvbG9yLFxuICAgICAgICAgICAgICAgIGxpZ2h0bmVzc0NvbnRyb2xQb2ludHMsXG4gICAgICAgICAgICAgICAgY2hyb21hQ29udHJvbFBvaW50c1xuICAgICAgICAgICAgICApXG4gICAgICAgICAgICA6IGdlbmVyYXRlQ29sb3JTY2FsZShjb2xvcik7XG4gICAgICAgIHNldEFjY2VudENvbG9yU2NhbGUoYWNjZW50U2NhbGUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAnbmV1dHJhbCc6XG4gICAgICAgIHNldE5ldXRyYWxDb2xvcihjb2xvcik7XG4gICAgICAgIC8vIEdlbmVyYXRlIG5ldXRyYWxzIGJhc2VkIG9uIHRoZSBzZWxlY3RlZCBjb2xvclxuICAgICAgICBjb25zdCBuZXdOZXV0cmFsU2NhbGUgPSBnZW5lcmF0ZU5ldXRyYWxzKGNvbG9yKTtcbiAgICAgICAgc2V0TmV1dHJhbENvbG9yU2NhbGUobmV3TmV1dHJhbFNjYWxlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IHZhbHVlID0ge1xuICAgIHByaW1hcnlDb2xvcixcbiAgICBzZXRQcmltYXJ5Q29sb3IsXG4gICAgcHJpbWFyeUNvbG9yU2NhbGUsXG4gICAgc2V0UHJpbWFyeUNvbG9yU2NhbGUsXG5cbiAgICBhY2NlbnRDb2xvcixcbiAgICBzZXRBY2NlbnRDb2xvcixcbiAgICBhY2NlbnRDb2xvclNjYWxlLFxuICAgIHNldEFjY2VudENvbG9yU2NhbGUsXG5cbiAgICBuZXV0cmFsQ29sb3IsXG4gICAgc2V0TmV1dHJhbENvbG9yLFxuICAgIG5ldXRyYWxDb2xvclNjYWxlLFxuICAgIHNldE5ldXRyYWxDb2xvclNjYWxlLFxuXG4gICAgc2V0QmFzZUNvbG9yLFxuXG4gICAgbGlnaHRuZXNzQ29udHJvbFBvaW50cyxcbiAgICBzZXRMaWdodG5lc3NDb250cm9sUG9pbnRzLFxuXG4gICAgY2hyb21hQ29udHJvbFBvaW50cyxcbiAgICBzZXRDaHJvbWFDb250cm9sUG9pbnRzLFxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPERlc2lnblN5c3RlbUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e3ZhbHVlfT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L0Rlc2lnblN5c3RlbUNvbnRleHQuUHJvdmlkZXI+XG4gICk7XG59O1xuXG4vLyBDdXN0b20gaG9vayB0byB1c2UgdGhlIGRlc2lnbiBzeXN0ZW0gY29udGV4dFxuZXhwb3J0IGNvbnN0IHVzZURlc2lnblN5c3RlbSA9ICgpID0+IHtcbiAgY29uc3QgY29udGV4dCA9IHVzZUNvbnRleHQoRGVzaWduU3lzdGVtQ29udGV4dCk7XG4gIGlmIChjb250ZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAndXNlRGVzaWduU3lzdGVtIG11c3QgYmUgdXNlZCB3aXRoaW4gYSBEZXNpZ25TeXN0ZW1Qcm92aWRlcidcbiAgICApO1xuICB9XG4gIHJldHVybiBjb250ZXh0O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgRGVzaWduU3lzdGVtQ29udGV4dDtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJnZW5lcmF0ZUNvbG9yU2NhbGUiLCJhcHBseUNvbG9yQ3VydmVzIiwiZ2VuZXJhdGVOZXV0cmFscyIsIkRlc2lnblN5c3RlbUNvbnRleHQiLCJ1bmRlZmluZWQiLCJEZXNpZ25TeXN0ZW1Qcm92aWRlciIsImNoaWxkcmVuIiwiaW5pdGlhbFByaW1hcnlDb2xvciIsImluaXRpYWxBY2NlbnRDb2xvciIsInByaW1hcnlDb2xvciIsInNldFByaW1hcnlDb2xvciIsInByaW1hcnlDb2xvclNjYWxlIiwic2V0UHJpbWFyeUNvbG9yU2NhbGUiLCJhY2NlbnRDb2xvciIsInNldEFjY2VudENvbG9yIiwiYWNjZW50Q29sb3JTY2FsZSIsInNldEFjY2VudENvbG9yU2NhbGUiLCJuZXV0cmFsQ29sb3IiLCJzZXROZXV0cmFsQ29sb3IiLCJuZXV0cmFsQ29sb3JTY2FsZSIsInNldE5ldXRyYWxDb2xvclNjYWxlIiwibGlnaHRuZXNzQ29udHJvbFBvaW50cyIsInNldExpZ2h0bmVzc0NvbnRyb2xQb2ludHMiLCJjaHJvbWFDb250cm9sUG9pbnRzIiwic2V0Q2hyb21hQ29udHJvbFBvaW50cyIsInNldEJhc2VDb2xvciIsInR5cGUiLCJjb2xvciIsInByaW1hcnlTY2FsZSIsImxlbmd0aCIsIm5ldXRyYWxTY2FsZSIsImFjY2VudFNjYWxlIiwibmV3TmV1dHJhbFNjYWxlIiwidmFsdWUiLCJQcm92aWRlciIsInVzZURlc2lnblN5c3RlbSIsImNvbnRleHQiLCJFcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/context/DesignSystemContext.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/utils/colorUtils.ts":
/*!*********************************!*\
  !*** ./src/utils/colorUtils.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OKLCHToHex: () => (/* binding */ OKLCHToHex),\n/* harmony export */   applyColorCurves: () => (/* binding */ applyColorCurves),\n/* harmony export */   generateChromaPoints: () => (/* binding */ generateChromaPoints),\n/* harmony export */   generateColorScale: () => (/* binding */ generateColorScale),\n/* harmony export */   generateCurvePoints: () => (/* binding */ generateCurvePoints),\n/* harmony export */   generateCustomColorScale: () => (/* binding */ generateCustomColorScale),\n/* harmony export */   generateNeutrals: () => (/* binding */ generateNeutrals),\n/* harmony export */   getCurvePathDefinition: () => (/* binding */ getCurvePathDefinition),\n/* harmony export */   hexToHsl: () => (/* binding */ hexToHsl),\n/* harmony export */   hexToOKLCH: () => (/* binding */ hexToOKLCH),\n/* harmony export */   hexToRgb: () => (/* binding */ hexToRgb),\n/* harmony export */   hslToHex: () => (/* binding */ hslToHex),\n/* harmony export */   hslToRgb: () => (/* binding */ hslToRgb),\n/* harmony export */   rgbToHex: () => (/* binding */ rgbToHex),\n/* harmony export */   rgbToHsl: () => (/* binding */ rgbToHsl),\n/* harmony export */   uiPointsToControlPoints: () => (/* binding */ uiPointsToControlPoints)\n/* harmony export */ });\n/* __next_internal_client_entry_do_not_use__ hexToRgb,rgbToHex,rgbToHsl,hslToRgb,generateColorScale,generateCustomColorScale,uiPointsToControlPoints,generateNeutrals,generateCurvePoints,generateChromaPoints,getCurvePathDefinition,hexToOKLCH,OKLCHToHex,hexToHsl,applyColorCurves,hslToHex auto */ /**\n * Converts a hex color to RGB components\n */ function hexToRgb(hex) {\n    // Remove the hash if present\n    hex = hex.replace(/^#/, '');\n    // Parse the hex value\n    let r, g, b;\n    if (hex.length === 3) {\n        r = parseInt(hex[0] + hex[0], 16);\n        g = parseInt(hex[1] + hex[1], 16);\n        b = parseInt(hex[2] + hex[2], 16);\n    } else {\n        r = parseInt(hex.substring(0, 2), 16);\n        g = parseInt(hex.substring(2, 4), 16);\n        b = parseInt(hex.substring(4, 6), 16);\n    }\n    return {\n        r,\n        g,\n        b\n    };\n}\n/**\n * Converts RGB components to a hex color\n */ function rgbToHex(r, g, b) {\n    return '#' + (1 << 24 | r << 16 | g << 8 | b).toString(16).slice(1);\n}\n/**\n * Converts RGB to HSL components\n */ function rgbToHsl(r, g, b) {\n    r /= 255;\n    g /= 255;\n    b /= 255;\n    const max = Math.max(r, g, b);\n    const min = Math.min(r, g, b);\n    let h = 0;\n    let s = 0;\n    const l = (max + min) / 2;\n    if (max !== min) {\n        const d = max - min;\n        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n        switch(max){\n            case r:\n                h = (g - b) / d + (g < b ? 6 : 0);\n                break;\n            case g:\n                h = (b - r) / d + 2;\n                break;\n            case b:\n                h = (r - g) / d + 4;\n                break;\n        }\n        h /= 6;\n    }\n    return {\n        h,\n        s,\n        l\n    };\n}\n/**\n * Converts HSL to RGB components\n */ function hslToRgb(h, s, l) {\n    let r, g, b;\n    if (s === 0) {\n        // achromatic\n        r = g = b = l;\n    } else {\n        const hue2rgb = (p, q, t)=>{\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 1 / 2) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        };\n        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        const p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n    }\n    return {\n        r: Math.round(r * 255),\n        g: Math.round(g * 255),\n        b: Math.round(b * 255)\n    };\n}\n/**\n * Generates a color scale based on a base color\n * @param baseColor - The base color in hex format\n * @returns An object with color variants from 50 to 950\n */ function generateColorScale(baseColor) {\n    const rgb = hexToRgb(baseColor);\n    const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);\n    // Define lightness values for each step in the scale\n    const lightnessScale = {\n        '50': 0.97,\n        '100': 0.94,\n        '200': 0.86,\n        '300': 0.76,\n        '400': 0.66,\n        '500': 0.56,\n        '600': 0.46,\n        '700': 0.38,\n        '800': 0.3,\n        '900': 0.22,\n        '950': 0.14\n    };\n    // Adjust saturation based on base color's saturation\n    // For very low or very high saturation colors, we need to adjust to create a balanced scale\n    let saturationAdjust = 1;\n    if (hsl.s < 0.15) {\n        saturationAdjust = 3; // Boost saturation for gray-ish colors\n    } else if (hsl.s > 0.9) {\n        saturationAdjust = 0.85; // Reduce saturation for very saturated colors\n    }\n    const colorScale = {};\n    // Generate each step in the scale\n    Object.entries(lightnessScale).forEach((param)=>{\n        let [step, lightness] = param;\n        // Adjust saturation based on lightness\n        // Lighter colors should be less saturated, darker colors more saturated\n        let adjustedSaturation = hsl.s;\n        if (lightness > 0.7) {\n            adjustedSaturation = Math.min(1, hsl.s * 0.8 * saturationAdjust);\n        } else if (lightness < 0.3) {\n            adjustedSaturation = Math.min(1, hsl.s * 1.2 * saturationAdjust);\n        } else {\n            adjustedSaturation = Math.min(1, hsl.s * saturationAdjust);\n        }\n        const color = hslToRgb(hsl.h, adjustedSaturation, lightness);\n        colorScale[step] = rgbToHex(color.r, color.g, color.b);\n    });\n    return colorScale;\n}\n/**\n * Generates a color scale based on a base color and custom control points\n * @param baseColor - The base color in hex format\n * @param controlPoints - Array of control points to shape the curve\n * @returns An object with color variants from 50 to 950\n */ function generateCustomColorScale(baseColor) {\n    let controlPoints = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n    const rgb = hexToRgb(baseColor);\n    const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);\n    // Define the default shade positions on a scale of 0-1\n    const shadePositions = {\n        '50': 0,\n        '100': 0.1,\n        '200': 0.2,\n        '300': 0.3,\n        '400': 0.4,\n        '500': 0.5,\n        '600': 0.6,\n        '700': 0.7,\n        '800': 0.8,\n        '900': 0.9,\n        '950': 1\n    };\n    // If no control points are provided, create default ones\n    if (controlPoints.length === 0) {\n        controlPoints = [\n            {\n                position: 0,\n                lightness: 0.97\n            },\n            {\n                position: 0.25,\n                lightness: 0.85\n            },\n            {\n                position: 0.5,\n                lightness: 0.56\n            },\n            {\n                position: 0.75,\n                lightness: 0.32\n            },\n            {\n                position: 1,\n                lightness: 0.14\n            }\n        ];\n    }\n    // Make sure control points are sorted by position\n    controlPoints.sort((a, b)=>a.position - b.position);\n    const colorScale = {};\n    // Generate each step in the scale\n    Object.entries(shadePositions).forEach((param)=>{\n        let [shade, position] = param;\n        // Find the control points to interpolate between\n        let beforePoint = controlPoints[0];\n        let afterPoint = controlPoints[controlPoints.length - 1];\n        for(let i = 0; i < controlPoints.length - 1; i++){\n            const current = controlPoints[i];\n            const next = controlPoints[i + 1];\n            if (position >= current.position && position <= next.position) {\n                beforePoint = current;\n                afterPoint = next;\n                break;\n            }\n        }\n        // Interpolate lightness between control points\n        const t = (position - beforePoint.position) / (afterPoint.position - beforePoint.position || 1);\n        // Get lightness values with proper undefined checks\n        const beforeLightness = beforePoint.lightness !== undefined ? beforePoint.lightness : 0.5;\n        const afterLightness = afterPoint.lightness !== undefined ? afterPoint.lightness : 0.5;\n        const interpolatedLightness = beforeLightness + t * (afterLightness - beforeLightness);\n        // Determine the saturation for this shade\n        let adjustedSaturation = hsl.s;\n        // If saturation is specified in control points, interpolate it too\n        if (beforePoint.saturation !== undefined && afterPoint.saturation !== undefined) {\n            adjustedSaturation = beforePoint.saturation + t * (afterPoint.saturation - beforePoint.saturation);\n        } else {\n            // Default saturation behavior - lighter colors are less saturated\n            if (interpolatedLightness > 0.7) {\n                adjustedSaturation = hsl.s * 0.8;\n            } else if (interpolatedLightness < 0.3) {\n                adjustedSaturation = Math.min(1, hsl.s * 1.2);\n            }\n        }\n        // Ensure saturation is within bounds\n        adjustedSaturation = Math.max(0, Math.min(1, adjustedSaturation));\n        // Generate the color using the calculated values\n        const color = hslToRgb(hsl.h, adjustedSaturation, interpolatedLightness);\n        colorScale[shade] = rgbToHex(color.r, color.g, color.b);\n    });\n    return colorScale;\n}\n/**\n * Converts UI bezier curve points (x,y) to CurveControlPoint format\n * @param points Array of UI points from the BezierCurveEditor\n * @param isChroma Whether the points are for chroma curves (true) or lightness curves (false)\n * @returns Array of CurveControlPoint for use in color generation\n */ function uiPointsToControlPoints(points, isChroma) {\n    return points.map((point)=>{\n        // Normalize to 0-1 range\n        const position = point.x / 320;\n        const normalizedY = 1 - point.y / 320;\n        const controlPoint = {\n            position\n        };\n        if (isChroma) {\n            // For chroma curve, y controls saturation\n            controlPoint.saturation = normalizedY;\n        } else {\n            // For lightness curve, y controls lightness\n            controlPoint.lightness = normalizedY;\n        }\n        return controlPoint;\n    });\n}\n/**\n * Generates a set of neutral/grey colors that are derived from the primary color\n * @param primaryColor - The primary color in hex format\n * @returns An object with neutral color variants from 50 to 950\n */ function generateNeutrals(primaryColor) {\n    const primaryHsl = rgbToHsl(hexToRgb(primaryColor).r, hexToRgb(primaryColor).g, hexToRgb(primaryColor).b);\n    const neutralScale = {};\n    // Light shades (50-500)\n    for(let i = 0; i < 6; i++){\n        const shade = [\n            50,\n            100,\n            200,\n            300,\n            400,\n            500\n        ][i];\n        const lightness = 0.98 - i * 0.08; // 0.98 down to 0.58\n        // Create a very subtle hint of the primary hue\n        // Using a saturation that decreases as the shade gets lighter\n        const saturationFactor = 0.08 - i * 0.01;\n        const saturation = primaryHsl.s * saturationFactor;\n        neutralScale[shade.toString()] = hslToHex({\n            h: primaryHsl.h,\n            s: saturation,\n            l: lightness\n        });\n    }\n    // Dark shades (600-950)\n    for(let i = 0; i < 5; i++){\n        const shade = [\n            600,\n            700,\n            800,\n            900,\n            950\n        ][i];\n        const lightness = 0.48 - i * 0.08; // 0.48 down to 0.16\n        // For darker shades, slightly increase the saturation for visual interest\n        // but still keep it very subtle\n        const saturationFactor = 0.06 - i * 0.005;\n        const saturation = primaryHsl.s * saturationFactor;\n        neutralScale[shade.toString()] = hslToHex({\n            h: primaryHsl.h,\n            s: saturation,\n            l: lightness\n        });\n    }\n    return neutralScale;\n}\n/**\n * Calculates points to draw a color curve for a range of color shades\n * @param colorScale - Object containing the color scale\n * @param rangeStart - Starting shade (e.g. \"50\", \"600\")\n * @param rangeEnd - Ending shade (e.g. \"400\", \"950\")\n * @returns Array of points to draw the curve\n */ function generateCurvePoints(colorScale, rangeStart, rangeEnd) {\n    const points = [];\n    const shades = Object.keys(colorScale).sort((a, b)=>parseInt(a) - parseInt(b));\n    // Filter to only include shades within our range\n    const rangeShades = shades.filter((shade)=>{\n        const value = parseInt(shade);\n        return value >= parseInt(rangeStart) && value <= parseInt(rangeEnd);\n    });\n    if (rangeShades.length === 0) return points;\n    // Get first and last shade for normalization\n    const firstShade = parseInt(rangeShades[0]);\n    const lastShade = parseInt(rangeShades[rangeShades.length - 1]);\n    const range = lastShade - firstShade;\n    // Extract lightness values\n    rangeShades.forEach((shade)=>{\n        const color = colorScale[shade];\n        const hsl = rgbToHsl(hexToRgb(color).r, hexToRgb(color).g, hexToRgb(color).b);\n        // Calculate x position based on shade number\n        const x = (parseInt(shade) - firstShade) / range;\n        // y is inverted (1 - lightness) since in UI 0,0 is top left\n        const y = 1 - hsl.l;\n        points.push({\n            x,\n            y\n        });\n    });\n    return points;\n}\n/**\n * Calculates points to visualize chroma (saturation) for a range of color shades\n * @param colorScale - Object containing the color scale\n * @param rangeStart - Starting shade (e.g. \"50\", \"600\")\n * @param rangeEnd - Ending shade (e.g. \"400\", \"950\")\n * @returns Array of points with their positions and colors\n */ function generateChromaPoints(colorScale, rangeStart, rangeEnd) {\n    // Get all the shades between rangeStart and rangeEnd\n    const orderedShades = [\n        '50',\n        '100',\n        '200',\n        '300',\n        '400',\n        '500',\n        '600',\n        '700',\n        '800',\n        '900',\n        '950'\n    ];\n    const startIndex = orderedShades.indexOf(rangeStart);\n    const endIndex = orderedShades.indexOf(rangeEnd);\n    if (startIndex === -1 || endIndex === -1) {\n        throw new Error(\"Invalid range: \".concat(rangeStart, \"-\").concat(rangeEnd));\n    }\n    const shades = orderedShades.slice(Math.min(startIndex, endIndex), Math.max(startIndex, endIndex) + 1);\n    // Select a few representative points for the chroma visualization\n    // We'll use 3 points: start, middle, and end of the range\n    const chromaPoints = [];\n    // Choose 3 points from the range\n    const pointIndices = [\n        0,\n        Math.floor(shades.length / 2),\n        shades.length - 1\n    ];\n    pointIndices.forEach((pointIndex)=>{\n        const shade = shades[pointIndex];\n        const color = colorScale[shade];\n        const rgb = hexToRgb(color);\n        const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);\n        // Normalize the x position for the canvas\n        const x = startIndex < endIndex ? pointIndex / (shades.length - 1) : 1 - pointIndex / (shades.length - 1);\n        // Y position based on saturation\n        const y = 1 - hsl.s;\n        chromaPoints.push({\n            x,\n            y,\n            color\n        });\n    });\n    return chromaPoints;\n}\n// Get the SVG path definition for a curve\nfunction getCurvePathDefinition(points, width, height) {\n    let padding = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 20;\n    if (points.length < 2) return '';\n    const drawWidth = width - padding * 2;\n    const drawHeight = height - padding * 2;\n    // Map normalized points to SVG coordinates\n    const mappedPoints = points.map((point)=>({\n            x: padding + point.x * drawWidth,\n            y: padding + point.y * drawHeight\n        }));\n    // Start the path\n    let path = \"M \".concat(mappedPoints[0].x, \",\").concat(mappedPoints[0].y);\n    // For a smooth curve, use cubic bezier curves between points\n    for(let i = 0; i < mappedPoints.length - 1; i++){\n        const current = mappedPoints[i];\n        const next = mappedPoints[i + 1];\n        // Calculate control points for a smooth curve\n        const controlPointX1 = current.x + (next.x - current.x) * 0.5;\n        const controlPointY1 = current.y;\n        const controlPointX2 = next.x - (next.x - current.x) * 0.5;\n        const controlPointY2 = next.y;\n        path += \" C \".concat(controlPointX1, \",\").concat(controlPointY1, \" \").concat(controlPointX2, \",\").concat(controlPointY2, \" \").concat(next.x, \",\").concat(next.y);\n    }\n    return path;\n}\n/**\n * OKLCH color space conversions\n * OKLCH is perceptually uniform and provides better color scales\n */ // Convert sRGB to linear RGB\nfunction sRGBToLinear(x) {\n    return x <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);\n}\n// Convert linear RGB to sRGB\nfunction linearTosRGB(x) {\n    return x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055;\n}\n// Convert linear RGB to OKLAB\nfunction LRGBToOKLAB(L, M, S) {\n    const l = Math.cbrt(0.4122214708 * L + 0.5363325363 * M + 0.0514459929 * S);\n    const m = Math.cbrt(0.2119034982 * L + 0.6806995451 * M + 0.1073969566 * S);\n    const s = Math.cbrt(0.0883024619 * L + 0.2817188376 * M + 0.6299787005 * S);\n    return {\n        L: 0.2104542553 * l + 0.793617785 * m - 0.0040720468 * s,\n        a: 1.9779984951 * l - 2.428592205 * m + 0.4505937099 * s,\n        b: 0.0259040371 * l + 0.7827717662 * m - 0.808675766 * s\n    };\n}\n// Convert OKLAB to linear RGB\nfunction OKLABToLRGB(L, a, b) {\n    const l = L + 0.3963377774 * a + 0.2158037573 * b;\n    const m = L - 0.1055613458 * a - 0.0638541728 * b;\n    const s = L - 0.0894841775 * a - 1.291485548 * b;\n    const l3 = l * l * l;\n    const m3 = m * m * m;\n    const s3 = s * s * s;\n    return {\n        L: +4.0767416621 * l3 - 3.3077115913 * m3 + 0.2309699292 * s3,\n        M: -1.2684380046 * l3 + 2.6097574011 * m3 - 0.3413193965 * s3,\n        S: -0.0041960863 * l3 - 0.7034186147 * m3 + 1.707614701 * s3\n    };\n}\n// Convert OKLAB to OKLCH\nfunction OKLABToOKLCH(L, a, b) {\n    const C = Math.sqrt(a * a + b * b);\n    let h = Math.atan2(b, a) * 180 / Math.PI;\n    if (h < 0) h += 360;\n    return {\n        L,\n        C,\n        h\n    };\n}\n// Convert OKLCH to OKLAB\nfunction OKLCHToOKLAB(L, C, h) {\n    const hRad = h * Math.PI / 180;\n    const a = C * Math.cos(hRad);\n    const b = C * Math.sin(hRad);\n    return {\n        L,\n        a,\n        b\n    };\n}\n// Convert hex to OKLCH\nfunction hexToOKLCH(hex) {\n    const { r, g, b } = hexToRgb(hex);\n    const lr = sRGBToLinear(r / 255);\n    const lg = sRGBToLinear(g / 255);\n    const lb = sRGBToLinear(b / 255);\n    const lab = LRGBToOKLAB(lr, lg, lb);\n    return OKLABToOKLCH(lab.L, lab.a, lab.b);\n}\n// Convert OKLCH to hex\nfunction OKLCHToHex(L, C, h) {\n    const lab = OKLCHToOKLAB(L, C, h);\n    const rgb = OKLABToLRGB(lab.L, lab.a, lab.b);\n    // Clamp and convert to sRGB\n    const r = Math.max(0, Math.min(255, Math.round(linearTosRGB(rgb.L) * 255)));\n    const g = Math.max(0, Math.min(255, Math.round(linearTosRGB(rgb.M) * 255)));\n    const b = Math.max(0, Math.min(255, Math.round(linearTosRGB(rgb.S) * 255)));\n    return rgbToHex(r, g, b);\n}\n/**\n * Converts a hex color value to HSL components\n */ function hexToHsl(hex) {\n    const rgb = hexToRgb(hex);\n    return rgbToHsl(rgb.r, rgb.g, rgb.b);\n}\n/**\n * Applies curve control points to generate a color scale\n */ function applyColorCurves(baseColor) {\n    let lightnessControlPoints = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], chromaControlPoints = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];\n    try {\n        // Default lightness control points - creates a natural progression\n        const defaultLightnessPoints = [\n            {\n                position: 0,\n                lightness: 0.98\n            },\n            {\n                position: 0.2,\n                lightness: 0.9\n            },\n            {\n                position: 0.4,\n                lightness: 0.75\n            },\n            {\n                position: 0.5,\n                lightness: 0.6\n            },\n            {\n                position: 0.6,\n                lightness: 0.45\n            },\n            {\n                position: 0.8,\n                lightness: 0.25\n            },\n            {\n                position: 1,\n                lightness: 0.1\n            }\n        ];\n        // Default chroma control points (constant saturation across the scale)\n        const defaultChromaPoints = [\n            {\n                position: 0,\n                saturation: 0.7\n            },\n            {\n                position: 0.2,\n                saturation: 0.85\n            },\n            {\n                position: 0.4,\n                saturation: 0.95\n            },\n            {\n                position: 0.5,\n                saturation: 1.0\n            },\n            {\n                position: 0.6,\n                saturation: 0.95\n            },\n            {\n                position: 0.8,\n                saturation: 0.85\n            },\n            {\n                position: 1,\n                saturation: 0.7\n            }\n        ];\n        // Use provided control points or defaults\n        const lightnessPoints = lightnessControlPoints.length > 0 ? lightnessControlPoints : defaultLightnessPoints;\n        const chromaPoints = chromaControlPoints.length > 0 ? chromaControlPoints : defaultChromaPoints;\n        // Convert base color to HSL\n        const { r, g, b } = hexToRgb(baseColor);\n        const baseHsl = rgbToHsl(r, g, b);\n        // Define the color steps to generate\n        const colorSteps = [\n            50,\n            100,\n            200,\n            300,\n            400,\n            500,\n            600,\n            700,\n            800,\n            900,\n            950\n        ];\n        const colorScale = {};\n        // Generate each shade in the scale\n        colorSteps.forEach((step, index)=>{\n            // Calculate position in the scale (0 to 1)\n            const position = index / (colorSteps.length - 1);\n            // Interpolate lightness and chroma (saturation)\n            const lightnessValue = interpolateLightness(position, lightnessPoints);\n            const chromaMultiplier = interpolateChroma(position, chromaPoints);\n            // Adjust saturation based on chroma multiplier (clamped to valid range)\n            const adjustedSaturation = Math.min(1, Math.max(0, baseHsl.s * chromaMultiplier));\n            // Generate the color\n            colorScale[step.toString()] = hslToHex({\n                h: baseHsl.h,\n                s: adjustedSaturation,\n                l: lightnessValue\n            });\n        });\n        return colorScale;\n    } catch (error) {\n        console.error('Error generating color scale:', error);\n        return generateColorScale(baseColor); // Fallback to default scale\n    }\n}\n/**\n * Interpolates lightness value based on position and control points\n */ function interpolateLightness(position, controlPoints) {\n    // Sort control points by position\n    const sortedPoints = [\n        ...controlPoints\n    ].sort((a, b)=>a.position - b.position);\n    // Handle edge cases\n    if (sortedPoints.length === 0) return 0.5; // Default to mid-gray\n    if (sortedPoints.length === 1 && sortedPoints[0].lightness !== undefined) {\n        return sortedPoints[0].lightness;\n    }\n    // Find the two control points that contain our position\n    let lower = sortedPoints[0];\n    let upper = sortedPoints[sortedPoints.length - 1];\n    for(let i = 0; i < sortedPoints.length - 1; i++){\n        if (position >= sortedPoints[i].position && position <= sortedPoints[i + 1].position) {\n            lower = sortedPoints[i];\n            upper = sortedPoints[i + 1];\n            break;\n        }\n    }\n    // If either point doesn't have a lightness value, use a default\n    const lowerLightness = lower.lightness !== undefined ? lower.lightness : 0.5;\n    const upperLightness = upper.lightness !== undefined ? upper.lightness : 0.5;\n    // Calculate interpolation factor\n    const range = upper.position - lower.position;\n    if (range === 0) return lowerLightness;\n    const factor = (position - lower.position) / range;\n    // Linear interpolation\n    return lowerLightness + factor * (upperLightness - lowerLightness);\n}\n/**\n * Interpolates chroma (saturation) multiplier based on position and control points\n */ function interpolateChroma(position, controlPoints) {\n    // Sort control points by position\n    const sortedPoints = [\n        ...controlPoints\n    ].sort((a, b)=>a.position - b.position);\n    // Handle edge cases\n    if (sortedPoints.length === 0) return 1.0; // Default to no change\n    if (sortedPoints.length === 1 && sortedPoints[0].saturation !== undefined) {\n        return sortedPoints[0].saturation;\n    }\n    // Find the two control points that contain our position\n    let lower = sortedPoints[0];\n    let upper = sortedPoints[sortedPoints.length - 1];\n    for(let i = 0; i < sortedPoints.length - 1; i++){\n        if (position >= sortedPoints[i].position && position <= sortedPoints[i + 1].position) {\n            lower = sortedPoints[i];\n            upper = sortedPoints[i + 1];\n            break;\n        }\n    }\n    // If either point doesn't have a saturation value, use a default\n    const lowerSaturation = lower.saturation !== undefined ? lower.saturation : 1.0;\n    const upperSaturation = upper.saturation !== undefined ? upper.saturation : 1.0;\n    // Calculate interpolation factor\n    const range = upper.position - lower.position;\n    if (range === 0) return lowerSaturation;\n    const factor = (position - lower.position) / range;\n    // Linear interpolation\n    return lowerSaturation + factor * (upperSaturation - lowerSaturation);\n}\n/**\n * Convert an HSL color to hex format\n */ function hslToHex(hsl) {\n    const { h, s, l } = hsl;\n    const rgb = hslToRgb(h, s, l);\n    return rgbToHex(rgb.r, rgb.g, rgb.b);\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9jb2xvclV0aWxzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7dVNBRUE7O0NBRUMsR0FDTSxTQUFTQSxTQUFTQyxHQUFXO0lBQ2xDLDZCQUE2QjtJQUM3QkEsTUFBTUEsSUFBSUMsT0FBTyxDQUFDLE1BQU07SUFFeEIsc0JBQXNCO0lBQ3RCLElBQUlDLEdBQUdDLEdBQUdDO0lBQ1YsSUFBSUosSUFBSUssTUFBTSxLQUFLLEdBQUc7UUFDcEJILElBQUlJLFNBQVNOLEdBQUcsQ0FBQyxFQUFFLEdBQUdBLEdBQUcsQ0FBQyxFQUFFLEVBQUU7UUFDOUJHLElBQUlHLFNBQVNOLEdBQUcsQ0FBQyxFQUFFLEdBQUdBLEdBQUcsQ0FBQyxFQUFFLEVBQUU7UUFDOUJJLElBQUlFLFNBQVNOLEdBQUcsQ0FBQyxFQUFFLEdBQUdBLEdBQUcsQ0FBQyxFQUFFLEVBQUU7SUFDaEMsT0FBTztRQUNMRSxJQUFJSSxTQUFTTixJQUFJTyxTQUFTLENBQUMsR0FBRyxJQUFJO1FBQ2xDSixJQUFJRyxTQUFTTixJQUFJTyxTQUFTLENBQUMsR0FBRyxJQUFJO1FBQ2xDSCxJQUFJRSxTQUFTTixJQUFJTyxTQUFTLENBQUMsR0FBRyxJQUFJO0lBQ3BDO0lBRUEsT0FBTztRQUFFTDtRQUFHQztRQUFHQztJQUFFO0FBQ25CO0FBRUE7O0NBRUMsR0FDTSxTQUFTSSxTQUFTTixDQUFTLEVBQUVDLENBQVMsRUFBRUMsQ0FBUztJQUN0RCxPQUFPLE1BQU0sQ0FBQyxLQUFNLEtBQU9GLEtBQUssS0FBT0MsS0FBSyxJQUFLQyxDQUFBQSxFQUFHSyxRQUFRLENBQUMsSUFBSUMsS0FBSyxDQUFDO0FBQ3pFO0FBRUE7O0NBRUMsR0FDTSxTQUFTQyxTQUNkVCxDQUFTLEVBQ1RDLENBQVMsRUFDVEMsQ0FBUztJQUVURixLQUFLO0lBQ0xDLEtBQUs7SUFDTEMsS0FBSztJQUVMLE1BQU1RLE1BQU1DLEtBQUtELEdBQUcsQ0FBQ1YsR0FBR0Ms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aUM7SUFDakMsTUFBTTBCLFFBQVFzRSxNQUFNN0csUUFBUSxHQUFHNEcsTUFBTTVHLFFBQVE7SUFDN0MsSUFBSXVDLFVBQVUsR0FBRyxPQUFPMEU7SUFFeEIsTUFBTUQsU0FBUyxDQUFDaEgsV0FBVzRHLE1BQU01RyxRQUFRLElBQUl1QztJQUU3Qyx1QkFBdUI7SUFDdkIsT0FBTzBFLGtCQUFrQkQsU0FBVUUsQ0FBQUEsa0JBQWtCRCxlQUFjO0FBQ3JFO0FBRUE7O0NBRUMsR0FDTSxTQUFTckYsU0FBUzFDLEdBQXdDO0lBQy9ELE1BQU0sRUFBRWIsQ0FBQyxFQUFFQyxDQUFDLEVBQUVDLENBQUMsRUFBRSxHQUFHVztJQUNwQixNQUFNRCxNQUFNUixTQUFTSixHQUFHQyxHQUFHQztJQUMzQixPQUFPVCxTQUFTbUIsSUFBSXpCLENBQUMsRUFBRXlCLElBQUl4QixDQUFDLEVBQUV3QixJQUFJdkIsQ0FBQztBQUNyQyIsInNvdXJjZXMiOlsiL1VzZXJzL25hdGUvcHJvamVjdHMvZGVzaWduLXN5c3RlbS1idWlsZGVyL3NyYy91dGlscy9jb2xvclV0aWxzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50JztcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGhleCBjb2xvciB0byBSR0IgY29tcG9uZW50c1xuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9SZ2IoaGV4OiBzdHJpbmcpOiB7IHI6IG51bWJlcjsgZzogbnVtYmVyOyBiOiBudW1iZXIgfSB7XG4gIC8vIFJlbW92ZSB0aGUgaGFzaCBpZiBwcmVzZW50XG4gIGhleCA9IGhleC5yZXBsYWNlKC9eIy8sICcnKTtcblxuICAvLyBQYXJzZSB0aGUgaGV4IHZhbHVlXG4gIGxldCByLCBnLCBiO1xuICBpZiAoaGV4Lmxlbmd0aCA9PT0gMykge1xuICAgIHIgPSBwYXJzZUludChoZXhbMF0gKyBoZXhbMF0sIDE2KTtcbiAgICBnID0gcGFyc2VJbnQoaGV4WzFdICsgaGV4WzFdLCAxNik7XG4gICAgYiA9IHBhcnNlSW50KGhleFsyXSArIGhleFsyXSwgMTYpO1xuICB9IGVsc2Uge1xuICAgIHIgPSBwYXJzZUludChoZXguc3Vic3RyaW5nKDAsIDIpLCAxNik7XG4gICAgZyA9IHBhcnNlSW50KGhleC5zdWJzdHJpbmcoMiwgNCksIDE2KTtcbiAgICBiID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZyg0LCA2KSwgMTYpO1xuICB9XG5cbiAgcmV0dXJuIHsgciwgZywgYiB9O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIFJHQiBjb21wb25lbnRzIHRvIGEgaGV4IGNvbG9yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByZ2JUb0hleChyOiBudW1iZXIsIGc6IG51bWJlciwgYjogbnVtYmVyKTogc3RyaW5nIHtcbiAgcmV0dXJuICcjJyArICgoMSA8PCAyNCkgfCAociA8PCAxNikgfCAoZyA8PCA4KSB8IGIpLnRvU3RyaW5nKDE2KS5zbGljZSgxKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBSR0IgdG8gSFNMIGNvbXBvbmVudHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJnYlRvSHNsKFxuICByOiBudW1iZXIsXG4gIGc6IG51bWJlcixcbiAgYjogbnVtYmVyXG4pOiB7IGg6IG51bWJlcjsgczogbnVtYmVyOyBsOiBudW1iZXIgfSB7XG4gIHIgLz0gMjU1O1xuICBnIC89IDI1NTtcbiAgYiAvPSAyNTU7XG5cbiAgY29uc3QgbWF4ID0gTWF0aC5tYXgociwgZywgYik7XG4gIGNvbnN0IG1pbiA9IE1hdGgubWluKHIsIGcsIGIpO1xuICBsZXQgaCA9IDA7XG4gIGxldCBzID0gMDtcbiAgY29uc3QgbCA9IChtYXggKyBtaW4pIC8gMjtcblxuICBpZiAobWF4ICE9PSBtaW4pIHtcbiAgICBjb25zdCBkID0gbWF4IC0gbWluO1xuICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcblxuICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICBjYXNlIHI6XG4gICAgICAgIGggPSAoZyAtIGIpIC8gZCArIChnIDwgYiA/IDYgOiAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIGc6XG4gICAgICAgIGggPSAoYiAtIHIpIC8gZCArIDI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBiOlxuICAgICAgICBoID0gKHIgLSBnKSAvIGQgKyA0O1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBoIC89IDY7XG4gIH1cblxuICByZXR1cm4geyBoLCBzLCBsIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgSFNMIHRvIFJHQiBjb21wb25lbnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoc2xUb1JnYihcbiAgaDogbnVtYmVyLFxuICBzOiBudW1iZXIsXG4gIGw6IG51bWJlclxuKTogeyByOiBudW1iZXI7IGc6IG51bWJlcjsgYjogbnVtYmVyIH0ge1xuICBsZXQgciwgZywgYjtcblxuICBpZiAocyA9PT0gMCkge1xuICAgIC8vIGFjaHJvbWF0aWNcbiAgICByID0gZyA9IGIgPSBsO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGh1ZTJyZ2IgPSAocDogbnVtYmVyLCBxOiBudW1iZXIsIHQ6IG51bWJlcik6IG51bWJlciA9PiB7XG4gICAgICBpZiAodCA8IDApIHQgKz0gMTtcbiAgICAgIGlmICh0ID4gMSkgdCAtPSAxO1xuICAgICAgaWYgKHQgPCAxIC8gNikgcmV0dXJuIHAgKyAocSAtIHApICogNiAqIHQ7XG4gICAgICBpZiAodCA8IDEgLyAyKSByZXR1cm4gcTtcbiAgICAgIGlmICh0IDwgMiAvIDMpIHJldHVybiBwICsgKHEgLSBwKSAqICgyIC8gMyAtIHQpICogNjtcbiAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICBjb25zdCBxID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcztcbiAgICBjb25zdCBwID0gMiAqIGwgLSBxO1xuXG4gICAgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKTtcbiAgICBnID0gaHVlMnJnYihwLCBxLCBoKTtcbiAgICBiID0gaHVlMnJnYihwLCBxLCBoIC0gMSAvIDMpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByOiBNYXRoLnJvdW5kKHIgKiAyNTUpLFxuICAgIGc6IE1hdGgucm91bmQoZyAqIDI1NSksXG4gICAgYjogTWF0aC5yb3VuZChiICogMjU1KSxcbiAgfTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBjb2xvciBzY2FsZSBiYXNlZCBvbiBhIGJhc2UgY29sb3JcbiAqIEBwYXJhbSBiYXNlQ29sb3IgLSBUaGUgYmFzZSBjb2xvciBpbiBoZXggZm9ybWF0XG4gKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCBjb2xvciB2YXJpYW50cyBmcm9tIDUwIHRvIDk1MFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVDb2xvclNjYWxlKGJhc2VDb2xvcjogc3RyaW5nKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gIGNvbnN0IHJnYiA9IGhleFRvUmdiKGJhc2VDb2xvcik7XG4gIGNvbnN0IGhzbCA9IHJnYlRvSHNsKHJnYi5yLCByZ2IuZywgcmdiLmIpO1xuXG4gIC8vIERlZmluZSBsaWdodG5lc3MgdmFsdWVzIGZvciBlYWNoIHN0ZXAgaW4gdGhlIHNjYWxlXG4gIGNvbnN0IGxpZ2h0bmVzc1NjYWxlID0ge1xuICAgICc1MCc6IDAuOTcsXG4gICAgJzEwMCc6IDAuOTQsXG4gICAgJzIwMCc6IDAuODYsXG4gICAgJzMwMCc6IDAuNzYsXG4gICAgJzQwMCc6IDAuNjYsXG4gICAgJzUwMCc6IDAuNTYsIC8vIFRoaXMgaXMgY2xvc2VzdCB0byB0aGUgYmFzZSBjb2xvclxuICAgICc2MDAnOiAwLjQ2LFxuICAgICc3MDAnOiAwLjM4LFxuICAgICc4MDAnOiAwLjMsXG4gICAgJzkwMCc6IDAuMjIsXG4gICAgJzk1MCc6IDAuMTQsXG4gIH07XG5cbiAgLy8gQWRqdXN0IHNhdHVyYXRpb24gYmFzZWQgb24gYmFzZSBjb2xvcidzIHNhdHVyYXRpb25cbiAgLy8gRm9yIHZlcnkgbG93IG9yIHZlcnkgaGlnaCBzYXR1cmF0aW9uIGNvbG9ycywgd2UgbmVlZCB0byBhZGp1c3QgdG8gY3JlYXRlIGEgYmFsYW5jZWQgc2NhbGVcbiAgbGV0IHNhdHVyYXRpb25BZGp1c3QgPSAxO1xuICBpZiAoaHNsLnMgPCAwLjE1KSB7XG4gICAgc2F0dXJhdGlvbkFkanVzdCA9IDM7IC8vIEJvb3N0IHNhdHVyYXRpb24gZm9yIGdyYXktaXNoIGNvbG9yc1xuICB9IGVsc2UgaWYgKGhzbC5zID4gMC45KSB7XG4gICAgc2F0dXJhdGlvbkFkanVzdCA9IDAuODU7IC8vIFJlZHVjZSBzYXR1cmF0aW9uIGZvciB2ZXJ5IHNhdHVyYXRlZCBjb2xvcnNcbiAgfVxuXG4gIGNvbnN0IGNvbG9yU2NhbGU6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcblxuICAvLyBHZW5lcmF0ZSBlYWNoIHN0ZXAgaW4gdGhlIHNjYWxlXG4gIE9iamVjdC5lbnRyaWVzKGxpZ2h0bmVzc1NjYWxlKS5mb3JFYWNoKChbc3RlcCwgbGlnaHRuZXNzXSkgPT4ge1xuICAgIC8vIEFkanVzdCBzYXR1cmF0aW9uIGJhc2VkIG9uIGxpZ2h0bmVzc1xuICAgIC8vIExpZ2h0ZXIgY29sb3JzIHNob3VsZCBiZSBsZXNzIHNhdHVyYXRlZCwgZGFya2VyIGNvbG9ycyBtb3JlIHNhdHVyYXRlZFxuICAgIGxldCBhZGp1c3RlZFNhdHVyYXRpb24gPSBoc2wucztcbiAgICBpZiAobGlnaHRuZXNzID4gMC43KSB7XG4gICAgICBhZGp1c3RlZFNhdHVyYXRpb24gPSBNYXRoLm1pbigxLCBoc2wucyAqIDAuOCAqIHNhdHVyYXRpb25BZGp1c3QpO1xuICAgIH0gZWxzZSBpZiAobGlnaHRuZXNzIDwgMC4zKSB7XG4gICAgICBhZGp1c3RlZFNhdHVyYXRpb24gPSBNYXRoLm1pbigxLCBoc2wucyAqIDEuMiAqIHNhdHVyYXRpb25BZGp1c3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGp1c3RlZFNhdHVyYXRpb24gPSBNYXRoLm1pbigxLCBoc2wucyAqIHNhdHVyYXRpb25BZGp1c3QpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbG9yID0gaHNsVG9SZ2IoaHNsLmgsIGFkanVzdGVkU2F0dXJhdGlvbiwgbGlnaHRuZXNzKTtcbiAgICBjb2xvclNjYWxlW3N0ZXBdID0gcmdiVG9IZXgoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gIH0pO1xuXG4gIHJldHVybiBjb2xvclNjYWxlO1xufVxuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgYSBjb250cm9sIHBvaW50IG9uIGEgY29sb3IgY3VydmVcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBDdXJ2ZUNvbnRyb2xQb2ludCB7XG4gIHBvc2l0aW9uOiBudW1iZXI7XG4gIGxpZ2h0bmVzcz86IG51bWJlcjtcbiAgc2F0dXJhdGlvbj86IG51bWJlcjsgLy8gU2F0dXJhdGlvbiBtdWx0aXBsaWVyIGZvciBjb250cm9sbGluZyBjaHJvbWFcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBjb2xvciBzY2FsZSBiYXNlZCBvbiBhIGJhc2UgY29sb3IgYW5kIGN1c3RvbSBjb250cm9sIHBvaW50c1xuICogQHBhcmFtIGJhc2VDb2xvciAtIFRoZSBiYXNlIGNvbG9yIGluIGhleCBmb3JtYXRcbiAqIEBwYXJhbSBjb250cm9sUG9pbnRzIC0gQXJyYXkgb2YgY29udHJvbCBwb2ludHMgdG8gc2hhcGUgdGhlIGN1cnZlXG4gKiBAcmV0dXJucyBBbiBvYmplY3Qgd2l0aCBjb2xvciB2YXJpYW50cyBmcm9tIDUwIHRvIDk1MFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVDdXN0b21Db2xvclNjYWxlKFxuICBiYXNlQ29sb3I6IHN0cmluZyxcbiAgY29udHJvbFBvaW50czogQ3VydmVDb250cm9sUG9pbnRbXSA9IFtdXG4pOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgY29uc3QgcmdiID0gaGV4VG9SZ2IoYmFzZUNvbG9yKTtcbiAgY29uc3QgaHNsID0gcmdiVG9Ic2wocmdiLnIsIHJnYi5nLCByZ2IuYik7XG5cbiAgLy8gRGVmaW5lIHRoZSBkZWZhdWx0IHNoYWRlIHBvc2l0aW9ucyBvbiBhIHNjYWxlIG9mIDAtMVxuICBjb25zdCBzaGFkZVBvc2l0aW9ucyA9IHtcbiAgICAnNTAnOiAwLFxuICAgICcxMDAnOiAwLjEsXG4gICAgJzIwMCc6IDAuMixcbiAgICAnMzAwJzogMC4zLFxuICAgICc0MDAnOiAwLjQsXG4gICAgJzUwMCc6IDAuNSwgLy8gTWlkZGxlIHBvaW50XG4gICAgJzYwMCc6IDAuNixcbiAgICAnNzAwJzogMC43LFxuICAgICc4MDAnOiAwLjgsXG4gICAgJzkwMCc6IDAuOSxcbiAgICAnOTUwJzogMSxcbiAgfTtcblxuICAvLyBJZiBubyBjb250cm9sIHBvaW50cyBhcmUgcHJvdmlkZWQsIGNyZWF0ZSBkZWZhdWx0IG9uZXNcbiAgaWYgKGNvbnRyb2xQb2ludHMubGVuZ3RoID09PSAwKSB7XG4gICAgY29udHJvbFBvaW50cyA9IFtcbiAgICAgIHsgcG9zaXRpb246IDAsIGxpZ2h0bmVzczogMC45NyB9LCAvLyA1MFxuICAgICAgeyBwb3NpdGlvbjogMC4yNSwgbGlnaHRuZXNzOiAwLjg1IH0sIC8vIEFyb3VuZCAyMDBcbiAgICAgIHsgcG9zaXRpb246IDAuNSwgbGlnaHRuZXNzOiAwLjU2IH0sIC8vIDUwMCAoYmFzZSlcbiAgICAgIHsgcG9zaXRpb246IDAuNzUsIGxpZ2h0bmVzczogMC4zMiB9LCAvLyBBcm91bmQgNzAwXG4gICAgICB7IHBvc2l0aW9uOiAxLCBsaWdodG5lc3M6IDAuMTQgfSwgLy8gOTUwXG4gICAgXTtcbiAgfVxuXG4gIC8vIE1ha2Ugc3VyZSBjb250cm9sIHBvaW50cyBhcmUgc29ydGVkIGJ5IHBvc2l0aW9uXG4gIGNvbnRyb2xQb2ludHMuc29ydCgoYSwgYikgPT4gYS5wb3NpdGlvbiAtIGIucG9zaXRpb24pO1xuXG4gIGNvbnN0IGNvbG9yU2NhbGU6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcblxuICAvLyBHZW5lcmF0ZSBlYWNoIHN0ZXAgaW4gdGhlIHNjYWxlXG4gIE9iamVjdC5lbnRyaWVzKHNoYWRlUG9zaXRpb25zKS5mb3JFYWNoKChbc2hhZGUsIHBvc2l0aW9uXSkgPT4ge1xuICAgIC8vIEZpbmQgdGhlIGNvbnRyb2wgcG9pbnRzIHRvIGludGVycG9sYXRlIGJldHdlZW5cbiAgICBsZXQgYmVmb3JlUG9pbnQgPSBjb250cm9sUG9pbnRzWzBdO1xuICAgIGxldCBhZnRlclBvaW50ID0gY29udHJvbFBvaW50c1tjb250cm9sUG9pbnRzLmxlbmd0aCAtIDFdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb250cm9sUG9pbnRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgY29uc3QgY3VycmVudCA9IGNvbnRyb2xQb2ludHNbaV07XG4gICAgICBjb25zdCBuZXh0ID0gY29udHJvbFBvaW50c1tpICsgMV07XG5cbiAgICAgIGlmIChwb3NpdGlvbiA+PSBjdXJyZW50LnBvc2l0aW9uICYmIHBvc2l0aW9uIDw9IG5leHQucG9zaXRpb24pIHtcbiAgICAgICAgYmVmb3JlUG9pbnQgPSBjdXJyZW50O1xuICAgICAgICBhZnRlclBvaW50ID0gbmV4dDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW50ZXJwb2xhdGUgbGlnaHRuZXNzIGJldHdlZW4gY29udHJvbCBwb2ludHNcbiAgICBjb25zdCB0ID1cbiAgICAgIChwb3NpdGlvbiAtIGJlZm9yZVBvaW50LnBvc2l0aW9uKSAvXG4gICAgICAoYWZ0ZXJQb2ludC5wb3NpdGlvbiAtIGJlZm9yZVBvaW50LnBvc2l0aW9uIHx8IDEpO1xuXG4gICAgLy8gR2V0IGxpZ2h0bmVzcyB2YWx1ZXMgd2l0aCBwcm9wZXIgdW5kZWZpbmVkIGNoZWNrc1xuICAgIGNvbnN0IGJlZm9yZUxpZ2h0bmVzcyA9XG4gICAgICBiZWZvcmVQb2ludC5saWdodG5lc3MgIT09IHVuZGVmaW5lZCA/IGJlZm9yZVBvaW50LmxpZ2h0bmVzcyA6IDAuNTtcbiAgICBjb25zdCBhZnRlckxpZ2h0bmVzcyA9XG4gICAgICBhZnRlclBvaW50LmxpZ2h0bmVzcyAhPT0gdW5kZWZpbmVkID8gYWZ0ZXJQb2ludC5saWdodG5lc3MgOiAwLjU7XG5cbiAgICBjb25zdCBpbnRlcnBvbGF0ZWRMaWdodG5lc3MgPVxuICAgICAgYmVmb3JlTGlnaHRuZXNzICsgdCAqIChhZnRlckxpZ2h0bmVzcyAtIGJlZm9yZUxpZ2h0bmVzcyk7XG5cbiAgICAvLyBEZXRlcm1pbmUgdGhlIHNhdHVyYXRpb24gZm9yIHRoaXMgc2hhZGVcbiAgICBsZXQgYWRqdXN0ZWRTYXR1cmF0aW9uID0gaHNsLnM7XG5cbiAgICAvLyBJZiBzYXR1cmF0aW9uIGlzIHNwZWNpZmllZCBpbiBjb250cm9sIHBvaW50cywgaW50ZXJwb2xhdGUgaXQgdG9vXG4gICAgaWYgKFxuICAgICAgYmVmb3JlUG9pbnQuc2F0dXJhdGlvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICBhZnRlclBvaW50LnNhdHVyYXRpb24gIT09IHVuZGVmaW5lZFxuICAgICkge1xuICAgICAgYWRqdXN0ZWRTYXR1cmF0aW9uID1cbiAgICAgICAgYmVmb3JlUG9pbnQuc2F0dXJhdGlvbiArXG4gICAgICAgIHQgKiAoYWZ0ZXJQb2ludC5zYXR1cmF0aW9uIC0gYmVmb3JlUG9pbnQuc2F0dXJhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlZmF1bHQgc2F0dXJhdGlvbiBiZWhhdmlvciAtIGxpZ2h0ZXIgY29sb3JzIGFyZSBsZXNzIHNhdHVyYXRlZFxuICAgICAgaWYgKGludGVycG9sYXRlZExpZ2h0bmVzcyA+IDAuNykge1xuICAgICAgICBhZGp1c3RlZFNhdHVyYXRpb24gPSBoc2wucyAqIDAuODtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGVkTGlnaHRuZXNzIDwgMC4zKSB7XG4gICAgICAgIGFkanVzdGVkU2F0dXJhdGlvbiA9IE1hdGgubWluKDEsIGhzbC5zICogMS4yKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbnN1cmUgc2F0dXJhdGlvbiBpcyB3aXRoaW4gYm91bmRzXG4gICAgYWRqdXN0ZWRTYXR1cmF0aW9uID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgYWRqdXN0ZWRTYXR1cmF0aW9uKSk7XG5cbiAgICAvLyBHZW5lcmF0ZSB0aGUgY29sb3IgdXNpbmcgdGhlIGNhbGN1bGF0ZWQgdmFsdWVzXG4gICAgY29uc3QgY29sb3IgPSBoc2xUb1JnYihoc2wuaCwgYWRqdXN0ZWRTYXR1cmF0aW9uLCBpbnRlcnBvbGF0ZWRMaWdodG5lc3MpO1xuICAgIGNvbG9yU2NhbGVbc2hhZGVdID0gcmdiVG9IZXgoY29sb3IuciwgY29sb3IuZywgY29sb3IuYik7XG4gIH0pO1xuXG4gIHJldHVybiBjb2xvclNjYWxlO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIFVJIGJlemllciBjdXJ2ZSBwb2ludHMgKHgseSkgdG8gQ3VydmVDb250cm9sUG9pbnQgZm9ybWF0XG4gKiBAcGFyYW0gcG9pbnRzIEFycmF5IG9mIFVJIHBvaW50cyBmcm9tIHRoZSBCZXppZXJDdXJ2ZUVkaXRvclxuICogQHBhcmFtIGlzQ2hyb21hIFdoZXRoZXIgdGhlIHBvaW50cyBhcmUgZm9yIGNocm9tYSBjdXJ2ZXMgKHRydWUpIG9yIGxpZ2h0bmVzcyBjdXJ2ZXMgKGZhbHNlKVxuICogQHJldHVybnMgQXJyYXkgb2YgQ3VydmVDb250cm9sUG9pbnQgZm9yIHVzZSBpbiBjb2xvciBnZW5lcmF0aW9uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1aVBvaW50c1RvQ29udHJvbFBvaW50cyhcbiAgcG9pbnRzOiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH1bXSxcbiAgaXNDaHJvbWE6IGJvb2xlYW5cbik6IEN1cnZlQ29udHJvbFBvaW50W10ge1xuICByZXR1cm4gcG9pbnRzLm1hcCgocG9pbnQpID0+IHtcbiAgICAvLyBOb3JtYWxpemUgdG8gMC0xIHJhbmdlXG4gICAgY29uc3QgcG9zaXRpb24gPSBwb2ludC54IC8gMzIwO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRZID0gMSAtIHBvaW50LnkgLyAzMjA7XG5cbiAgICBjb25zdCBjb250cm9sUG9pbnQ6IEN1cnZlQ29udHJvbFBvaW50ID0ge1xuICAgICAgcG9zaXRpb24sXG4gICAgfTtcblxuICAgIGlmIChpc0Nocm9tYSkge1xuICAgICAgLy8gRm9yIGNocm9tYSBjdXJ2ZSwgeSBjb250cm9scyBzYXR1cmF0aW9uXG4gICAgICBjb250cm9sUG9pbnQuc2F0dXJhdGlvbiA9IG5vcm1hbGl6ZWRZO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgbGlnaHRuZXNzIGN1cnZlLCB5IGNvbnRyb2xzIGxpZ2h0bmVzc1xuICAgICAgY29udHJvbFBvaW50LmxpZ2h0bmVzcyA9IG5vcm1hbGl6ZWRZO1xuICAgIH1cblxuICAgIHJldHVybiBjb250cm9sUG9pbnQ7XG4gIH0pO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIHNldCBvZiBuZXV0cmFsL2dyZXkgY29sb3JzIHRoYXQgYXJlIGRlcml2ZWQgZnJvbSB0aGUgcHJpbWFyeSBjb2xvclxuICogQHBhcmFtIHByaW1hcnlDb2xvciAtIFRoZSBwcmltYXJ5IGNvbG9yIGluIGhleCBmb3JtYXRcbiAqIEByZXR1cm5zIEFuIG9iamVjdCB3aXRoIG5ldXRyYWwgY29sb3IgdmFyaWFudHMgZnJvbSA1MCB0byA5NTBcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlTmV1dHJhbHMocHJpbWFyeUNvbG9yOiBzdHJpbmcpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgY29uc3QgcHJpbWFyeUhzbCA9IHJnYlRvSHNsKFxuICAgIGhleFRvUmdiKHByaW1hcnlDb2xvcikucixcbiAgICBoZXhUb1JnYihwcmltYXJ5Q29sb3IpLmcsXG4gICAgaGV4VG9SZ2IocHJpbWFyeUNvbG9yKS5iXG4gICk7XG4gIGNvbnN0IG5ldXRyYWxTY2FsZTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuXG4gIC8vIExpZ2h0IHNoYWRlcyAoNTAtNTAwKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgIGNvbnN0IHNoYWRlID0gWzUwLCAxMDAsIDIwMCwgMzAwLCA0MDAsIDUwMF1baV07XG4gICAgY29uc3QgbGlnaHRuZXNzID0gMC45OCAtIGkgKiAwLjA4OyAvLyAwLjk4IGRvd24gdG8gMC41OFxuXG4gICAgLy8gQ3JlYXRlIGEgdmVyeSBzdWJ0bGUgaGludCBvZiB0aGUgcHJpbWFyeSBodWVcbiAgICAvLyBVc2luZyBhIHNhdHVyYXRpb24gdGhhdCBkZWNyZWFzZXMgYXMgdGhlIHNoYWRlIGdldHMgbGlnaHRlclxuICAgIGNvbnN0IHNhdHVyYXRpb25GYWN0b3IgPSAwLjA4IC0gaSAqIDAuMDE7XG4gICAgY29uc3Qgc2F0dXJhdGlvbiA9IHByaW1hcnlIc2wucyAqIHNhdHVyYXRpb25GYWN0b3I7XG5cbiAgICBuZXV0cmFsU2NhbGVbc2hhZGUudG9TdHJpbmcoKV0gPSBoc2xUb0hleCh7XG4gICAgICBoOiBwcmltYXJ5SHNsLmgsXG4gICAgICBzOiBzYXR1cmF0aW9uLFxuICAgICAgbDogbGlnaHRuZXNzLFxuICAgIH0pO1xuICB9XG5cbiAgLy8gRGFyayBzaGFkZXMgKDYwMC05NTApXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7XG4gICAgY29uc3Qgc2hhZGUgPSBbNjAwLCA3MDAsIDgwMCwgOTAwLCA5NTBdW2ldO1xuICAgIGNvbnN0IGxpZ2h0bmVzcyA9IDAuNDggLSBpICogMC4wODsgLy8gMC40OCBkb3duIHRvIDAuMTZcblxuICAgIC8vIEZvciBkYXJrZXIgc2hhZGVzLCBzbGlnaHRseSBpbmNyZWFzZSB0aGUgc2F0dXJhdGlvbiBmb3IgdmlzdWFsIGludGVyZXN0XG4gICAgLy8gYnV0IHN0aWxsIGtlZXAgaXQgdmVyeSBzdWJ0bGVcbiAgICBjb25zdCBzYXR1cmF0aW9uRmFjdG9yID0gMC4wNiAtIGkgKiAwLjAwNTtcbiAgICBjb25zdCBzYXR1cmF0aW9uID0gcHJpbWFyeUhzbC5zICogc2F0dXJhdGlvbkZhY3RvcjtcblxuICAgIG5ldXRyYWxTY2FsZVtzaGFkZS50b1N0cmluZygpXSA9IGhzbFRvSGV4KHtcbiAgICAgIGg6IHByaW1hcnlIc2wuaCxcbiAgICAgIHM6IHNhdHVyYXRpb24sXG4gICAgICBsOiBsaWdodG5lc3MsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbmV1dHJhbFNjYWxlO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZXMgcG9pbnRzIHRvIGRyYXcgYSBjb2xvciBjdXJ2ZSBmb3IgYSByYW5nZSBvZiBjb2xvciBzaGFkZXNcbiAqIEBwYXJhbSBjb2xvclNjYWxlIC0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNvbG9yIHNjYWxlXG4gKiBAcGFyYW0gcmFuZ2VTdGFydCAtIFN0YXJ0aW5nIHNoYWRlIChlLmcuIFwiNTBcIiwgXCI2MDBcIilcbiAqIEBwYXJhbSByYW5nZUVuZCAtIEVuZGluZyBzaGFkZSAoZS5nLiBcIjQwMFwiLCBcIjk1MFwiKVxuICogQHJldHVybnMgQXJyYXkgb2YgcG9pbnRzIHRvIGRyYXcgdGhlIGN1cnZlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZUN1cnZlUG9pbnRzKFxuICBjb2xvclNjYWxlOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICByYW5nZVN0YXJ0OiBzdHJpbmcsXG4gIHJhbmdlRW5kOiBzdHJpbmdcbik6IEFycmF5PHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfT4ge1xuICBjb25zdCBwb2ludHM6IEFycmF5PHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfT4gPSBbXTtcbiAgY29uc3Qgc2hhZGVzID0gT2JqZWN0LmtleXMoY29sb3JTY2FsZSkuc29ydChcbiAgICAoYSwgYikgPT4gcGFyc2VJbnQoYSkgLSBwYXJzZUludChiKVxuICApO1xuXG4gIC8vIEZpbHRlciB0byBvbmx5IGluY2x1ZGUgc2hhZGVzIHdpdGhpbiBvdXIgcmFuZ2VcbiAgY29uc3QgcmFuZ2VTaGFkZXMgPSBzaGFkZXMuZmlsdGVyKChzaGFkZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gcGFyc2VJbnQoc2hhZGUpO1xuICAgIHJldHVybiB2YWx1ZSA+PSBwYXJzZUludChyYW5nZVN0YXJ0KSAmJiB2YWx1ZSA8PSBwYXJzZUludChyYW5nZUVuZCk7XG4gIH0pO1xuXG4gIGlmIChyYW5nZVNoYWRlcy5sZW5ndGggPT09IDApIHJldHVybiBwb2ludHM7XG5cbiAgLy8gR2V0IGZpcnN0IGFuZCBsYXN0IHNoYWRlIGZvciBub3JtYWxpemF0aW9uXG4gIGNvbnN0IGZpcnN0U2hhZGUgPSBwYXJzZUludChyYW5nZVNoYWRlc1swXSk7XG4gIGNvbnN0IGxhc3RTaGFkZSA9IHBhcnNlSW50KHJhbmdlU2hhZGVzW3JhbmdlU2hhZGVzLmxlbmd0aCAtIDFdKTtcbiAgY29uc3QgcmFuZ2UgPSBsYXN0U2hhZGUgLSBmaXJzdFNoYWRlO1xuXG4gIC8vIEV4dHJhY3QgbGlnaHRuZXNzIHZhbHVlc1xuICByYW5nZVNoYWRlcy5mb3JFYWNoKChzaGFkZSkgPT4ge1xuICAgIGNvbnN0IGNvbG9yID0gY29sb3JTY2FsZVtzaGFkZV07XG4gICAgY29uc3QgaHNsID0gcmdiVG9Ic2woXG4gICAgICBoZXhUb1JnYihjb2xvcikucixcbiAgICAgIGhleFRvUmdiKGNvbG9yKS5nLFxuICAgICAgaGV4VG9SZ2IoY29sb3IpLmJcbiAgICApO1xuXG4gICAgLy8gQ2FsY3VsYXRlIHggcG9zaXRpb24gYmFzZWQgb24gc2hhZGUgbnVtYmVyXG4gICAgY29uc3QgeCA9IChwYXJzZUludChzaGFkZSkgLSBmaXJzdFNoYWRlKSAvIHJhbmdlO1xuXG4gICAgLy8geSBpcyBpbnZlcnRlZCAoMSAtIGxpZ2h0bmVzcykgc2luY2UgaW4gVUkgMCwwIGlzIHRvcCBsZWZ0XG4gICAgY29uc3QgeSA9IDEgLSBoc2wubDtcblxuICAgIHBvaW50cy5wdXNoKHsgeCwgeSB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIHBvaW50cztcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGVzIHBvaW50cyB0byB2aXN1YWxpemUgY2hyb21hIChzYXR1cmF0aW9uKSBmb3IgYSByYW5nZSBvZiBjb2xvciBzaGFkZXNcbiAqIEBwYXJhbSBjb2xvclNjYWxlIC0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIGNvbG9yIHNjYWxlXG4gKiBAcGFyYW0gcmFuZ2VTdGFydCAtIFN0YXJ0aW5nIHNoYWRlIChlLmcuIFwiNTBcIiwgXCI2MDBcIilcbiAqIEBwYXJhbSByYW5nZUVuZCAtIEVuZGluZyBzaGFkZSAoZS5nLiBcIjQwMFwiLCBcIjk1MFwiKVxuICogQHJldHVybnMgQXJyYXkgb2YgcG9pbnRzIHdpdGggdGhlaXIgcG9zaXRpb25zIGFuZCBjb2xvcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ2hyb21hUG9pbnRzKFxuICBjb2xvclNjYWxlOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+LFxuICByYW5nZVN0YXJ0OiBzdHJpbmcsXG4gIHJhbmdlRW5kOiBzdHJpbmdcbik6IEFycmF5PHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IGNvbG9yOiBzdHJpbmcgfT4ge1xuICAvLyBHZXQgYWxsIHRoZSBzaGFkZXMgYmV0d2VlbiByYW5nZVN0YXJ0IGFuZCByYW5nZUVuZFxuICBjb25zdCBvcmRlcmVkU2hhZGVzID0gW1xuICAgICc1MCcsXG4gICAgJzEwMCcsXG4gICAgJzIwMCcsXG4gICAgJzMwMCcsXG4gICAgJzQwMCcsXG4gICAgJzUwMCcsXG4gICAgJzYwMCcsXG4gICAgJzcwMCcsXG4gICAgJzgwMCcsXG4gICAgJzkwMCcsXG4gICAgJzk1MCcsXG4gIF07XG5cbiAgY29uc3Qgc3RhcnRJbmRleCA9IG9yZGVyZWRTaGFkZXMuaW5kZXhPZihyYW5nZVN0YXJ0KTtcbiAgY29uc3QgZW5kSW5kZXggPSBvcmRlcmVkU2hhZGVzLmluZGV4T2YocmFuZ2VFbmQpO1xuXG4gIGlmIChzdGFydEluZGV4ID09PSAtMSB8fCBlbmRJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcmFuZ2U6ICR7cmFuZ2VTdGFydH0tJHtyYW5nZUVuZH1gKTtcbiAgfVxuXG4gIGNvbnN0IHNoYWRlcyA9IG9yZGVyZWRTaGFkZXMuc2xpY2UoXG4gICAgTWF0aC5taW4oc3RhcnRJbmRleCwgZW5kSW5kZXgpLFxuICAgIE1hdGgubWF4KHN0YXJ0SW5kZXgsIGVuZEluZGV4KSArIDFcbiAgKTtcblxuICAvLyBTZWxlY3QgYSBmZXcgcmVwcmVzZW50YXRpdmUgcG9pbnRzIGZvciB0aGUgY2hyb21hIHZpc3VhbGl6YXRpb25cbiAgLy8gV2UnbGwgdXNlIDMgcG9pbnRzOiBzdGFydCwgbWlkZGxlLCBhbmQgZW5kIG9mIHRoZSByYW5nZVxuICBjb25zdCBjaHJvbWFQb2ludHM6IEFycmF5PHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IGNvbG9yOiBzdHJpbmcgfT4gPSBbXTtcblxuICAvLyBDaG9vc2UgMyBwb2ludHMgZnJvbSB0aGUgcmFuZ2VcbiAgY29uc3QgcG9pbnRJbmRpY2VzID0gWzAsIE1hdGguZmxvb3Ioc2hhZGVzLmxlbmd0aCAvIDIpLCBzaGFkZXMubGVuZ3RoIC0gMV07XG5cbiAgcG9pbnRJbmRpY2VzLmZvckVhY2goKHBvaW50SW5kZXgpID0+IHtcbiAgICBjb25zdCBzaGFkZSA9IHNoYWRlc1twb2ludEluZGV4XTtcbiAgICBjb25zdCBjb2xvciA9IGNvbG9yU2NhbGVbc2hhZGVdO1xuICAgIGNvbnN0IHJnYiA9IGhleFRvUmdiKGNvbG9yKTtcbiAgICBjb25zdCBoc2wgPSByZ2JUb0hzbChyZ2IuciwgcmdiLmcsIHJnYi5iKTtcblxuICAgIC8vIE5vcm1hbGl6ZSB0aGUgeCBwb3NpdGlvbiBmb3IgdGhlIGNhbnZhc1xuICAgIGNvbnN0IHggPVxuICAgICAgc3RhcnRJbmRleCA8IGVuZEluZGV4XG4gICAgICAgID8gcG9pbnRJbmRleCAvIChzaGFkZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgOiAxIC0gcG9pbnRJbmRleCAvIChzaGFkZXMubGVuZ3RoIC0gMSk7XG5cbiAgICAvLyBZIHBvc2l0aW9uIGJhc2VkIG9uIHNhdHVyYXRpb25cbiAgICBjb25zdCB5ID0gMSAtIGhzbC5zO1xuXG4gICAgY2hyb21hUG9pbnRzLnB1c2goeyB4LCB5LCBjb2xvciB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGNocm9tYVBvaW50cztcbn1cblxuLy8gR2V0IHRoZSBTVkcgcGF0aCBkZWZpbml0aW9uIGZvciBhIGN1cnZlXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3VydmVQYXRoRGVmaW5pdGlvbihcbiAgcG9pbnRzOiBBcnJheTx7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0+LFxuICB3aWR0aDogbnVtYmVyLFxuICBoZWlnaHQ6IG51bWJlcixcbiAgcGFkZGluZzogbnVtYmVyID0gMjBcbik6IHN0cmluZyB7XG4gIGlmIChwb2ludHMubGVuZ3RoIDwgMikgcmV0dXJuICcnO1xuXG4gIGNvbnN0IGRyYXdXaWR0aCA9IHdpZHRoIC0gcGFkZGluZyAqIDI7XG4gIGNvbnN0IGRyYXdIZWlnaHQgPSBoZWlnaHQgLSBwYWRkaW5nICogMjtcblxuICAvLyBNYXAgbm9ybWFsaXplZCBwb2ludHMgdG8gU1ZHIGNvb3JkaW5hdGVzXG4gIGNvbnN0IG1hcHBlZFBvaW50cyA9IHBvaW50cy5tYXAoKHBvaW50KSA9PiAoe1xuICAgIHg6IHBhZGRpbmcgKyBwb2ludC54ICogZHJhd1dpZHRoLFxuICAgIHk6IHBhZGRpbmcgKyBwb2ludC55ICogZHJhd0hlaWdodCxcbiAgfSkpO1xuXG4gIC8vIFN0YXJ0IHRoZSBwYXRoXG4gIGxldCBwYXRoID0gYE0gJHttYXBwZWRQb2ludHNbMF0ueH0sJHttYXBwZWRQb2ludHNbMF0ueX1gO1xuXG4gIC8vIEZvciBhIHNtb290aCBjdXJ2ZSwgdXNlIGN1YmljIGJlemllciBjdXJ2ZXMgYmV0d2VlbiBwb2ludHNcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXBwZWRQb2ludHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgY29uc3QgY3VycmVudCA9IG1hcHBlZFBvaW50c1tpXTtcbiAgICBjb25zdCBuZXh0ID0gbWFwcGVkUG9pbnRzW2kgKyAxXTtcblxuICAgIC8vIENhbGN1bGF0ZSBjb250cm9sIHBvaW50cyBmb3IgYSBzbW9vdGggY3VydmVcbiAgICBjb25zdCBjb250cm9sUG9pbnRYMSA9IGN1cnJlbnQueCArIChuZXh0LnggLSBjdXJyZW50LngpICogMC41O1xuICAgIGNvbnN0IGNvbnRyb2xQb2ludFkxID0gY3VycmVudC55O1xuICAgIGNvbnN0IGNvbnRyb2xQb2ludFgyID0gbmV4dC54IC0gKG5leHQueCAtIGN1cnJlbnQueCkgKiAwLjU7XG4gICAgY29uc3QgY29udHJvbFBvaW50WTIgPSBuZXh0Lnk7XG5cbiAgICBwYXRoICs9IGAgQyAke2NvbnRyb2xQb2ludFgxfSwke2NvbnRyb2xQb2ludFkxfSAke2NvbnRyb2xQb2ludFgyfSwke2NvbnRyb2xQb2ludFkyfSAke25leHQueH0sJHtuZXh0Lnl9YDtcbiAgfVxuXG4gIHJldHVybiBwYXRoO1xufVxuXG4vKipcbiAqIE9LTENIIGNvbG9yIHNwYWNlIGNvbnZlcnNpb25zXG4gKiBPS0xDSCBpcyBwZXJjZXB0dWFsbHkgdW5pZm9ybSBhbmQgcHJvdmlkZXMgYmV0dGVyIGNvbG9yIHNjYWxlc1xuICovXG5cbi8vIENvbnZlcnQgc1JHQiB0byBsaW5lYXIgUkdCXG5mdW5jdGlvbiBzUkdCVG9MaW5lYXIoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIHggPD0gMC4wNDA0NSA/IHggLyAxMi45MiA6IE1hdGgucG93KCh4ICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG59XG5cbi8vIENvbnZlcnQgbGluZWFyIFJHQiB0byBzUkdCXG5mdW5jdGlvbiBsaW5lYXJUb3NSR0IoeDogbnVtYmVyKTogbnVtYmVyIHtcbiAgcmV0dXJuIHggPD0gMC4wMDMxMzA4ID8gMTIuOTIgKiB4IDogMS4wNTUgKiBNYXRoLnBvdyh4LCAxIC8gMi40KSAtIDAuMDU1O1xufVxuXG4vLyBDb252ZXJ0IGxpbmVhciBSR0IgdG8gT0tMQUJcbmZ1bmN0aW9uIExSR0JUb09LTEFCKFxuICBMOiBudW1iZXIsXG4gIE06IG51bWJlcixcbiAgUzogbnVtYmVyXG4pOiB7IEw6IG51bWJlcjsgYTogbnVtYmVyOyBiOiBudW1iZXIgfSB7XG4gIGNvbnN0IGwgPSBNYXRoLmNicnQoMC40MTIyMjE0NzA4ICogTCArIDAuNTM2MzMyNTM2MyAqIE0gKyAwLjA1MTQ0NTk5MjkgKiBTKTtcbiAgY29uc3QgbSA9IE1hdGguY2JydCgwLjIxMTkwMzQ5ODIgKiBMICsgMC42ODA2OTk1NDUxICogTSArIDAuMTA3Mzk2OTU2NiAqIFMpO1xuICBjb25zdCBzID0gTWF0aC5jYnJ0KDAuMDg4MzAyNDYxOSAqIEwgKyAwLjI4MTcxODgzNzYgKiBNICsgMC42Mjk5Nzg3MDA1ICogUyk7XG5cbiAgcmV0dXJuIHtcbiAgICBMOiAwLjIxMDQ1NDI1NTMgKiBsICsgMC43OTM2MTc3ODUgKiBtIC0gMC4wMDQwNzIwNDY4ICogcyxcbiAgICBhOiAxLjk3Nzk5ODQ5NTEgKiBsIC0gMi40Mjg1OTIyMDUgKiBtICsgMC40NTA1OTM3MDk5ICogcyxcbiAgICBiOiAwLjAyNTkwNDAzNzEgKiBsICsgMC43ODI3NzE3NjYyICogbSAtIDAuODA4Njc1NzY2ICogcyxcbiAgfTtcbn1cblxuLy8gQ29udmVydCBPS0xBQiB0byBsaW5lYXIgUkdCXG5mdW5jdGlvbiBPS0xBQlRvTFJHQihcbiAgTDogbnVtYmVyLFxuICBhOiBudW1iZXIsXG4gIGI6IG51bWJlclxuKTogeyBMOiBudW1iZXI7IE06IG51bWJlcjsgUzogbnVtYmVyIH0ge1xuICBjb25zdCBsID0gTCArIDAuMzk2MzM3Nzc3NCAqIGEgKyAwLjIxNTgwMzc1NzMgKiBiO1xuICBjb25zdCBtID0gTCAtIDAuMTA1NTYxMzQ1OCAqIGEgLSAwLjA2Mzg1NDE3MjggKiBiO1xuICBjb25zdCBzID0gTCAtIDAuMDg5NDg0MTc3NSAqIGEgLSAxLjI5MTQ4NTU0OCAqIGI7XG5cbiAgY29uc3QgbDMgPSBsICogbCAqIGw7XG4gIGNvbnN0IG0zID0gbSAqIG0gKiBtO1xuICBjb25zdCBzMyA9IHMgKiBzICogcztcblxuICByZXR1cm4ge1xuICAgIEw6ICs0LjA3Njc0MTY2MjEgKiBsMyAtIDMuMzA3NzExNTkxMyAqIG0zICsgMC4yMzA5Njk5MjkyICogczMsXG4gICAgTTogLTEuMjY4NDM4MDA0NiAqIGwzICsgMi42MDk3NTc0MDExICogbTMgLSAwLjM0MTMxOTM5NjUgKiBzMyxcbiAgICBTOiAtMC4wMDQxOTYwODYzICogbDMgLSAwLjcwMzQxODYxNDcgKiBtMyArIDEuNzA3NjE0NzAxICogczMsXG4gIH07XG59XG5cbi8vIENvbnZlcnQgT0tMQUIgdG8gT0tMQ0hcbmZ1bmN0aW9uIE9LTEFCVG9PS0xDSChcbiAgTDogbnVtYmVyLFxuICBhOiBudW1iZXIsXG4gIGI6IG51bWJlclxuKTogeyBMOiBudW1iZXI7IEM6IG51bWJlcjsgaDogbnVtYmVyIH0ge1xuICBjb25zdCBDID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuICBsZXQgaCA9IChNYXRoLmF0YW4yKGIsIGEpICogMTgwKSAvIE1hdGguUEk7XG4gIGlmIChoIDwgMCkgaCArPSAzNjA7XG5cbiAgcmV0dXJuIHsgTCwgQywgaCB9O1xufVxuXG4vLyBDb252ZXJ0IE9LTENIIHRvIE9LTEFCXG5mdW5jdGlvbiBPS0xDSFRvT0tMQUIoXG4gIEw6IG51bWJlcixcbiAgQzogbnVtYmVyLFxuICBoOiBudW1iZXJcbik6IHsgTDogbnVtYmVyOyBhOiBudW1iZXI7IGI6IG51bWJlciB9IHtcbiAgY29uc3QgaFJhZCA9IChoICogTWF0aC5QSSkgLyAxODA7XG4gIGNvbnN0IGEgPSBDICogTWF0aC5jb3MoaFJhZCk7XG4gIGNvbnN0IGIgPSBDICogTWF0aC5zaW4oaFJhZCk7XG4gIHJldHVybiB7IEwsIGEsIGIgfTtcbn1cblxuLy8gQ29udmVydCBoZXggdG8gT0tMQ0hcbmV4cG9ydCBmdW5jdGlvbiBoZXhUb09LTENIKGhleDogc3RyaW5nKTogeyBMOiBudW1iZXI7IEM6IG51bWJlcjsgaDogbnVtYmVyIH0ge1xuICBjb25zdCB7IHIsIGcsIGIgfSA9IGhleFRvUmdiKGhleCk7XG5cbiAgY29uc3QgbHIgPSBzUkdCVG9MaW5lYXIociAvIDI1NSk7XG4gIGNvbnN0IGxnID0gc1JHQlRvTGluZWFyKGcgLyAyNTUpO1xuICBjb25zdCBsYiA9IHNSR0JUb0xpbmVhcihiIC8gMjU1KTtcblxuICBjb25zdCBsYWIgPSBMUkdCVG9PS0xBQihsciwgbGcsIGxiKTtcbiAgcmV0dXJuIE9LTEFCVG9PS0xDSChsYWIuTCwgbGFiLmEsIGxhYi5iKTtcbn1cblxuLy8gQ29udmVydCBPS0xDSCB0byBoZXhcbmV4cG9ydCBmdW5jdGlvbiBPS0xDSFRvSGV4KEw6IG51bWJlciwgQzogbnVtYmVyLCBoOiBudW1iZXIpOiBzdHJpbmcge1xuICBjb25zdCBsYWIgPSBPS0xDSFRvT0tMQUIoTCwgQywgaCk7XG4gIGNvbnN0IHJnYiA9IE9LTEFCVG9MUkdCKGxhYi5MLCBsYWIuYSwgbGFiLmIpO1xuXG4gIC8vIENsYW1wIGFuZCBjb252ZXJ0IHRvIHNSR0JcbiAgY29uc3QgciA9IE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZChsaW5lYXJUb3NSR0IocmdiLkwpICogMjU1KSkpO1xuICBjb25zdCBnID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKGxpbmVhclRvc1JHQihyZ2IuTSkgKiAyNTUpKSk7XG4gIGNvbnN0IGIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQobGluZWFyVG9zUkdCKHJnYi5TKSAqIDI1NSkpKTtcblxuICByZXR1cm4gcmdiVG9IZXgociwgZywgYik7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBoZXggY29sb3IgdmFsdWUgdG8gSFNMIGNvbXBvbmVudHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvSHNsKGhleDogc3RyaW5nKTogeyBoOiBudW1iZXI7IHM6IG51bWJlcjsgbDogbnVtYmVyIH0ge1xuICBjb25zdCByZ2IgPSBoZXhUb1JnYihoZXgpO1xuICByZXR1cm4gcmdiVG9Ic2wocmdiLnIsIHJnYi5nLCByZ2IuYik7XG59XG5cbi8qKlxuICogQXBwbGllcyBjdXJ2ZSBjb250cm9sIHBvaW50cyB0byBnZW5lcmF0ZSBhIGNvbG9yIHNjYWxlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhcHBseUNvbG9yQ3VydmVzKFxuICBiYXNlQ29sb3I6IHN0cmluZyxcbiAgbGlnaHRuZXNzQ29udHJvbFBvaW50czogQ3VydmVDb250cm9sUG9pbnRbXSA9IFtdLFxuICBjaHJvbWFDb250cm9sUG9pbnRzOiBDdXJ2ZUNvbnRyb2xQb2ludFtdID0gW11cbik6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICB0cnkge1xuICAgIC8vIERlZmF1bHQgbGlnaHRuZXNzIGNvbnRyb2wgcG9pbnRzIC0gY3JlYXRlcyBhIG5hdHVyYWwgcHJvZ3Jlc3Npb25cbiAgICBjb25zdCBkZWZhdWx0TGlnaHRuZXNzUG9pbnRzOiBDdXJ2ZUNvbnRyb2xQb2ludFtdID0gW1xuICAgICAgeyBwb3NpdGlvbjogMCwgbGlnaHRuZXNzOiAwLjk4IH0sIC8vIDUwICh2ZXJ5IGxpZ2h0KVxuICAgICAgeyBwb3NpdGlvbjogMC4yLCBsaWdodG5lc3M6IDAuOSB9LCAvLyB+MjAwXG4gICAgICB7IHBvc2l0aW9uOiAwLjQsIGxpZ2h0bmVzczogMC43NSB9LCAvLyB+NDAwXG4gICAgICB7IHBvc2l0aW9uOiAwLjUsIGxpZ2h0bmVzczogMC42IH0sIC8vIDUwMCAoYmFzZSlcbiAgICAgIHsgcG9zaXRpb246IDAuNiwgbGlnaHRuZXNzOiAwLjQ1IH0sIC8vIH42MDBcbiAgICAgIHsgcG9zaXRpb246IDAuOCwgbGlnaHRuZXNzOiAwLjI1IH0sIC8vIH44MDBcbiAgICAgIHsgcG9zaXRpb246IDEsIGxpZ2h0bmVzczogMC4xIH0sIC8vIDk1MCAodmVyeSBkYXJrKVxuICAgIF07XG5cbiAgICAvLyBEZWZhdWx0IGNocm9tYSBjb250cm9sIHBvaW50cyAoY29uc3RhbnQgc2F0dXJhdGlvbiBhY3Jvc3MgdGhlIHNjYWxlKVxuICAgIGNvbnN0IGRlZmF1bHRDaHJvbWFQb2ludHM6IEN1cnZlQ29udHJvbFBvaW50W10gPSBbXG4gICAgICB7IHBvc2l0aW9uOiAwLCBzYXR1cmF0aW9uOiAwLjcgfSwgLy8gNTAgKHJlZHVjZWQgc2F0dXJhdGlvbiBmb3IgdmVyeSBsaWdodClcbiAgICAgIHsgcG9zaXRpb246IDAuMiwgc2F0dXJhdGlvbjogMC44NSB9LCAvLyB+MjAwXG4gICAgICB7IHBvc2l0aW9uOiAwLjQsIHNhdHVyYXRpb246IDAuOTUgfSwgLy8gfjQwMFxuICAgICAgeyBwb3NpdGlvbjogMC41LCBzYXR1cmF0aW9uOiAxLjAgfSwgLy8gNTAwIChiYXNlIC0gZnVsbCBzYXR1cmF0aW9uKVxuICAgICAgeyBwb3NpdGlvbjogMC42LCBzYXR1cmF0aW9uOiAwLjk1IH0sIC8vIH42MDBcbiAgICAgIHsgcG9zaXRpb246IDAuOCwgc2F0dXJhdGlvbjogMC44NSB9LCAvLyB+ODAwXG4gICAgICB7IHBvc2l0aW9uOiAxLCBzYXR1cmF0aW9uOiAwLjcgfSwgLy8gOTUwIChyZWR1Y2VkIHNhdHVyYXRpb24gZm9yIHZlcnkgZGFyaylcbiAgICBdO1xuXG4gICAgLy8gVXNlIHByb3ZpZGVkIGNvbnRyb2wgcG9pbnRzIG9yIGRlZmF1bHRzXG4gICAgY29uc3QgbGlnaHRuZXNzUG9pbnRzID1cbiAgICAgIGxpZ2h0bmVzc0NvbnRyb2xQb2ludHMubGVuZ3RoID4gMFxuICAgICAgICA/IGxpZ2h0bmVzc0NvbnRyb2xQb2ludHNcbiAgICAgICAgOiBkZWZhdWx0TGlnaHRuZXNzUG9pbnRzO1xuXG4gICAgY29uc3QgY2hyb21hUG9pbnRzID1cbiAgICAgIGNocm9tYUNvbnRyb2xQb2ludHMubGVuZ3RoID4gMFxuICAgICAgICA/IGNocm9tYUNvbnRyb2xQb2ludHNcbiAgICAgICAgOiBkZWZhdWx0Q2hyb21hUG9pbnRzO1xuXG4gICAgLy8gQ29udmVydCBiYXNlIGNvbG9yIHRvIEhTTFxuICAgIGNvbnN0IHsgciwgZywgYiB9ID0gaGV4VG9SZ2IoYmFzZUNvbG9yKTtcbiAgICBjb25zdCBiYXNlSHNsID0gcmdiVG9Ic2wociwgZywgYik7XG5cbiAgICAvLyBEZWZpbmUgdGhlIGNvbG9yIHN0ZXBzIHRvIGdlbmVyYXRlXG4gICAgY29uc3QgY29sb3JTdGVwcyA9IFs1MCwgMTAwLCAyMDAsIDMwMCwgNDAwLCA1MDAsIDYwMCwgNzAwLCA4MDAsIDkwMCwgOTUwXTtcbiAgICBjb25zdCBjb2xvclNjYWxlOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG5cbiAgICAvLyBHZW5lcmF0ZSBlYWNoIHNoYWRlIGluIHRoZSBzY2FsZVxuICAgIGNvbG9yU3RlcHMuZm9yRWFjaCgoc3RlcCwgaW5kZXgpID0+IHtcbiAgICAgIC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpbiB0aGUgc2NhbGUgKDAgdG8gMSlcbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gaW5kZXggLyAoY29sb3JTdGVwcy5sZW5ndGggLSAxKTtcblxuICAgICAgLy8gSW50ZXJwb2xhdGUgbGlnaHRuZXNzIGFuZCBjaHJvbWEgKHNhdHVyYXRpb24pXG4gICAgICBjb25zdCBsaWdodG5lc3NWYWx1ZSA9IGludGVycG9sYXRlTGlnaHRuZXNzKHBvc2l0aW9uLCBsaWdodG5lc3NQb2ludHMpO1xuICAgICAgY29uc3QgY2hyb21hTXVsdGlwbGllciA9IGludGVycG9sYXRlQ2hyb21hKHBvc2l0aW9uLCBjaHJvbWFQb2ludHMpO1xuXG4gICAgICAvLyBBZGp1c3Qgc2F0dXJhdGlvbiBiYXNlZCBvbiBjaHJvbWEgbXVsdGlwbGllciAoY2xhbXBlZCB0byB2YWxpZCByYW5nZSlcbiAgICAgIGNvbnN0IGFkanVzdGVkU2F0dXJhdGlvbiA9IE1hdGgubWluKFxuICAgICAgICAxLFxuICAgICAgICBNYXRoLm1heCgwLCBiYXNlSHNsLnMgKiBjaHJvbWFNdWx0aXBsaWVyKVxuICAgICAgKTtcblxuICAgICAgLy8gR2VuZXJhdGUgdGhlIGNvbG9yXG4gICAgICBjb2xvclNjYWxlW3N0ZXAudG9TdHJpbmcoKV0gPSBoc2xUb0hleCh7XG4gICAgICAgIGg6IGJhc2VIc2wuaCxcbiAgICAgICAgczogYWRqdXN0ZWRTYXR1cmF0aW9uLFxuICAgICAgICBsOiBsaWdodG5lc3NWYWx1ZSxcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbG9yU2NhbGU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBjb2xvciBzY2FsZTonLCBlcnJvcik7XG4gICAgcmV0dXJuIGdlbmVyYXRlQ29sb3JTY2FsZShiYXNlQ29sb3IpOyAvLyBGYWxsYmFjayB0byBkZWZhdWx0IHNjYWxlXG4gIH1cbn1cblxuLyoqXG4gKiBJbnRlcnBvbGF0ZXMgbGlnaHRuZXNzIHZhbHVlIGJhc2VkIG9uIHBvc2l0aW9uIGFuZCBjb250cm9sIHBvaW50c1xuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUxpZ2h0bmVzcyhcbiAgcG9zaXRpb246IG51bWJlcixcbiAgY29udHJvbFBvaW50czogQ3VydmVDb250cm9sUG9pbnRbXVxuKTogbnVtYmVyIHtcbiAgLy8gU29ydCBjb250cm9sIHBvaW50cyBieSBwb3NpdGlvblxuICBjb25zdCBzb3J0ZWRQb2ludHMgPSBbLi4uY29udHJvbFBvaW50c10uc29ydChcbiAgICAoYSwgYikgPT4gYS5wb3NpdGlvbiAtIGIucG9zaXRpb25cbiAgKTtcblxuICAvLyBIYW5kbGUgZWRnZSBjYXNlc1xuICBpZiAoc29ydGVkUG9pbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDAuNTsgLy8gRGVmYXVsdCB0byBtaWQtZ3JheVxuICBpZiAoc29ydGVkUG9pbnRzLmxlbmd0aCA9PT0gMSAmJiBzb3J0ZWRQb2ludHNbMF0ubGlnaHRuZXNzICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gc29ydGVkUG9pbnRzWzBdLmxpZ2h0bmVzcztcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIHR3byBjb250cm9sIHBvaW50cyB0aGF0IGNvbnRhaW4gb3VyIHBvc2l0aW9uXG4gIGxldCBsb3dlciA9IHNvcnRlZFBvaW50c1swXTtcbiAgbGV0IHVwcGVyID0gc29ydGVkUG9pbnRzW3NvcnRlZFBvaW50cy5sZW5ndGggLSAxXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNvcnRlZFBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBpZiAoXG4gICAgICBwb3NpdGlvbiA+PSBzb3J0ZWRQb2ludHNbaV0ucG9zaXRpb24gJiZcbiAgICAgIHBvc2l0aW9uIDw9IHNvcnRlZFBvaW50c1tpICsgMV0ucG9zaXRpb25cbiAgICApIHtcbiAgICAgIGxvd2VyID0gc29ydGVkUG9pbnRzW2ldO1xuICAgICAgdXBwZXIgPSBzb3J0ZWRQb2ludHNbaSArIDFdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgZWl0aGVyIHBvaW50IGRvZXNuJ3QgaGF2ZSBhIGxpZ2h0bmVzcyB2YWx1ZSwgdXNlIGEgZGVmYXVsdFxuICBjb25zdCBsb3dlckxpZ2h0bmVzcyA9IGxvd2VyLmxpZ2h0bmVzcyAhPT0gdW5kZWZpbmVkID8gbG93ZXIubGlnaHRuZXNzIDogMC41O1xuICBjb25zdCB1cHBlckxpZ2h0bmVzcyA9IHVwcGVyLmxpZ2h0bmVzcyAhPT0gdW5kZWZpbmVkID8gdXBwZXIubGlnaHRuZXNzIDogMC41O1xuXG4gIC8vIENhbGN1bGF0ZSBpbnRlcnBvbGF0aW9uIGZhY3RvclxuICBjb25zdCByYW5nZSA9IHVwcGVyLnBvc2l0aW9uIC0gbG93ZXIucG9zaXRpb247XG4gIGlmIChyYW5nZSA9PT0gMCkgcmV0dXJuIGxvd2VyTGlnaHRuZXNzO1xuXG4gIGNvbnN0IGZhY3RvciA9IChwb3NpdGlvbiAtIGxvd2VyLnBvc2l0aW9uKSAvIHJhbmdlO1xuXG4gIC8vIExpbmVhciBpbnRlcnBvbGF0aW9uXG4gIHJldHVybiBsb3dlckxpZ2h0bmVzcyArIGZhY3RvciAqICh1cHBlckxpZ2h0bmVzcyAtIGxvd2VyTGlnaHRuZXNzKTtcbn1cblxuLyoqXG4gKiBJbnRlcnBvbGF0ZXMgY2hyb21hIChzYXR1cmF0aW9uKSBtdWx0aXBsaWVyIGJhc2VkIG9uIHBvc2l0aW9uIGFuZCBjb250cm9sIHBvaW50c1xuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZUNocm9tYShcbiAgcG9zaXRpb246IG51bWJlcixcbiAgY29udHJvbFBvaW50czogQ3VydmVDb250cm9sUG9pbnRbXVxuKTogbnVtYmVyIHtcbiAgLy8gU29ydCBjb250cm9sIHBvaW50cyBieSBwb3NpdGlvblxuICBjb25zdCBzb3J0ZWRQb2ludHMgPSBbLi4uY29udHJvbFBvaW50c10uc29ydChcbiAgICAoYSwgYikgPT4gYS5wb3NpdGlvbiAtIGIucG9zaXRpb25cbiAgKTtcblxuICAvLyBIYW5kbGUgZWRnZSBjYXNlc1xuICBpZiAoc29ydGVkUG9pbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDEuMDsgLy8gRGVmYXVsdCB0byBubyBjaGFuZ2VcbiAgaWYgKHNvcnRlZFBvaW50cy5sZW5ndGggPT09IDEgJiYgc29ydGVkUG9pbnRzWzBdLnNhdHVyYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBzb3J0ZWRQb2ludHNbMF0uc2F0dXJhdGlvbjtcbiAgfVxuXG4gIC8vIEZpbmQgdGhlIHR3byBjb250cm9sIHBvaW50cyB0aGF0IGNvbnRhaW4gb3VyIHBvc2l0aW9uXG4gIGxldCBsb3dlciA9IHNvcnRlZFBvaW50c1swXTtcbiAgbGV0IHVwcGVyID0gc29ydGVkUG9pbnRzW3NvcnRlZFBvaW50cy5sZW5ndGggLSAxXTtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHNvcnRlZFBvaW50cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICBpZiAoXG4gICAgICBwb3NpdGlvbiA+PSBzb3J0ZWRQb2ludHNbaV0ucG9zaXRpb24gJiZcbiAgICAgIHBvc2l0aW9uIDw9IHNvcnRlZFBvaW50c1tpICsgMV0ucG9zaXRpb25cbiAgICApIHtcbiAgICAgIGxvd2VyID0gc29ydGVkUG9pbnRzW2ldO1xuICAgICAgdXBwZXIgPSBzb3J0ZWRQb2ludHNbaSArIDFdO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgZWl0aGVyIHBvaW50IGRvZXNuJ3QgaGF2ZSBhIHNhdHVyYXRpb24gdmFsdWUsIHVzZSBhIGRlZmF1bHRcbiAgY29uc3QgbG93ZXJTYXR1cmF0aW9uID1cbiAgICBsb3dlci5zYXR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBsb3dlci5zYXR1cmF0aW9uIDogMS4wO1xuICBjb25zdCB1cHBlclNhdHVyYXRpb24gPVxuICAgIHVwcGVyLnNhdHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IHVwcGVyLnNhdHVyYXRpb24gOiAxLjA7XG5cbiAgLy8gQ2FsY3VsYXRlIGludGVycG9sYXRpb24gZmFjdG9yXG4gIGNvbnN0IHJhbmdlID0gdXBwZXIucG9zaXRpb24gLSBsb3dlci5wb3NpdGlvbjtcbiAgaWYgKHJhbmdlID09PSAwKSByZXR1cm4gbG93ZXJTYXR1cmF0aW9uO1xuXG4gIGNvbnN0IGZhY3RvciA9IChwb3NpdGlvbiAtIGxvd2VyLnBvc2l0aW9uKSAvIHJhbmdlO1xuXG4gIC8vIExpbmVhciBpbnRlcnBvbGF0aW9uXG4gIHJldHVybiBsb3dlclNhdHVyYXRpb24gKyBmYWN0b3IgKiAodXBwZXJTYXR1cmF0aW9uIC0gbG93ZXJTYXR1cmF0aW9uKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEhTTCBjb2xvciB0byBoZXggZm9ybWF0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoc2xUb0hleChoc2w6IHsgaDogbnVtYmVyOyBzOiBudW1iZXI7IGw6IG51bWJlciB9KTogc3RyaW5nIHtcbiAgY29uc3QgeyBoLCBzLCBsIH0gPSBoc2w7XG4gIGNvbnN0IHJnYiA9IGhzbFRvUmdiKGgsIHMsIGwpO1xuICByZXR1cm4gcmdiVG9IZXgocmdiLnIsIHJnYi5nLCByZ2IuYik7XG59XG4iXSwibmFtZXMiOlsiaGV4VG9SZ2IiLCJoZXgiLCJyZXBsYWNlIiwiciIsImciLCJiIiwibGVuZ3RoIiwicGFyc2VJbnQiLCJzdWJzdHJpbmciLCJyZ2JUb0hleCIsInRvU3RyaW5nIiwic2xpY2UiLCJyZ2JUb0hzbCIsIm1heCIsIk1hdGgiLCJtaW4iLCJoIiwicyIsImwiLCJkIiwiaHNsVG9SZ2IiLCJodWUycmdiIiwicCIsInEiLCJ0Iiwicm91bmQiLCJnZW5lcmF0ZUNvbG9yU2NhbGUiLCJiYXNlQ29sb3IiLCJyZ2IiLCJoc2wiLCJsaWdodG5lc3NTY2FsZSIsInNhdHVyYXRpb25BZGp1c3QiLCJjb2xvclNjYWxlIiwiT2JqZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJzdGVwIiwibGlnaHRuZXNzIiwiYWRqdXN0ZWRTYXR1cmF0aW9uIiwiY29sb3IiLCJnZW5lcmF0ZUN1c3RvbUNvbG9yU2NhbGUiLCJjb250cm9sUG9pbnRzIiwic2hhZGVQb3NpdGlvbnMiLCJwb3NpdGlvbiIsInNvcnQiLCJhIiwic2hhZGUiLCJiZWZvcmVQb2ludCIsImFmdGVyUG9pbnQiLCJpIiwiY3VycmVudCIsIm5leHQiLCJiZWZvcmVMaWdodG5lc3MiLCJ1bmRlZmluZWQiLCJhZnRlckxpZ2h0bmVzcyIsImludGVycG9sYXRlZExpZ2h0bmVzcyIsInNhdHVyYXRpb24iLCJ1aVBvaW50c1RvQ29udHJvbFBvaW50cyIsInBvaW50cyIsImlzQ2hyb21hIiwibWFwIiwicG9pbnQiLCJ4Iiwibm9ybWFsaXplZFkiLCJ5IiwiY29udHJvbFBvaW50IiwiZ2VuZXJhdGVOZXV0cmFscyIsInByaW1hcnlDb2xvciIsInByaW1hcnlIc2wiLCJuZXV0cmFsU2NhbGUiLCJzYXR1cmF0aW9uRmFjdG9yIiwiaHNsVG9IZXgiLCJnZW5lcmF0ZUN1cnZlUG9pbnRzIiwicmFuZ2VTdGFydCIsInJhbmdlRW5kIiwic2hhZGVzIiwia2V5cyIsInJhbmdlU2hhZGVzIiwiZmlsdGVyIiwidmFsdWUiLCJmaXJzdFNoYWRlIiwibGFzdFNoYWRlIiwicmFuZ2UiLCJwdXNoIiwiZ2VuZXJhdGVDaHJvbWFQb2ludHMiLCJvcmRlcmVkU2hhZGVzIiwic3RhcnRJbmRleCIsImluZGV4T2YiLCJlbmRJbmRleCIsIkVycm9yIiwiY2hyb21hUG9pbnRzIiwicG9pbnRJbmRpY2VzIiwiZmxvb3IiLCJwb2ludEluZGV4IiwiZ2V0Q3VydmVQYXRoRGVmaW5pdGlvbiIsIndpZHRoIiwiaGVpZ2h0IiwicGFkZGluZyIsImRyYXdXaWR0aCIsImRyYXdIZWlnaHQiLCJtYXBwZWRQb2ludHMiLCJwYXRoIiwiY29udHJvbFBvaW50WDEiLCJjb250cm9sUG9pbnRZMSIsImNvbnRyb2xQb2ludFgyIiwiY29udHJvbFBvaW50WTIiLCJzUkdCVG9MaW5lYXIiLCJwb3ciLCJsaW5lYXJUb3NSR0IiLCJMUkdCVG9PS0xBQiIsIkwiLCJNIiwiUyIsImNicnQiLCJtIiwiT0tMQUJUb0xSR0IiLCJsMyIsIm0zIiwiczMiLCJPS0xBQlRvT0tMQ0giLCJDIiwic3FydCIsImF0YW4yIiwiUEkiLCJPS0xDSFRvT0tMQUIiLCJoUmFkIiwiY29zIiwic2luIiwiaGV4VG9PS0xDSCIsImxyIiwibGciLCJsYiIsImxhYiIsIk9LTENIVG9IZXgiLCJoZXhUb0hzbCIsImFwcGx5Q29sb3JDdXJ2ZXMiLCJsaWdodG5lc3NDb250cm9sUG9pbnRzIiwiY2hyb21hQ29udHJvbFBvaW50cyIsImRlZmF1bHRMaWdodG5lc3NQb2ludHMiLCJkZWZhdWx0Q2hyb21hUG9pbnRzIiwibGlnaHRuZXNzUG9pbnRzIiwiYmFzZUhzbCIsImNvbG9yU3RlcHMiLCJpbmRleCIsImxpZ2h0bmVzc1ZhbHVlIiwiaW50ZXJwb2xhdGVMaWdodG5lc3MiLCJjaHJvbWFNdWx0aXBsaWVyIiwiaW50ZXJwb2xhdGVDaHJvbWEiLCJlcnJvciIsImNvbnNvbGUiLCJzb3J0ZWRQb2ludHMiLCJsb3dlciIsInVwcGVyIiwibG93ZXJMaWdodG5lc3MiLCJ1cHBlckxpZ2h0bmVzcyIsImZhY3RvciIsImxvd2VyU2F0dXJhdGlvbiIsInVwcGVyU2F0dXJhdGlvbiJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/colorUtils.ts\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fnate%2Fprojects%2Fdesign-system-builder%2Fsrc%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fnate%2Fprojects%2Fdesign-system-builder%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%2Fapp%2Flayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Inter%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22inter%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Fnate%2Fprojects%2Fdesign-system-builder%2Fsrc%2Fcontext%2FDesignSystemContext.tsx%22%2C%22ids%22%3A%5B%22DesignSystemProvider%22%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);